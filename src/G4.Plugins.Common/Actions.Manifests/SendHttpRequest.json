{
	"aliases": [
		"InvokeWebRequest",
		"SendWebRequest"
	],
	"author": {
		"name": "Roei Sabag",
		"link": "https://www.linkedin.com/in/roei-sabag-247aa18/"
	},
	"categories": [
		"Http"
	],
	"context": {
		"integration": {
			"sequentialWorkflow": {
				"$type": "Action",
				"componentType": "task",
				"iconProvider": "http",
				"model": "ActionRuleModel"
			}
		}
	},
	"description": [
		"### Purpose",
		"",
		"The SendHttpRequest plugin automates sending HTTP requests to web services and REST APIs. ",
		"It lets users choose the HTTP method (GET, POST, PUT, DELETE, PATCH, or any other supported method) and set the request URL at run time. ",
		"It also lets users customize headers, body content, and query parameters. ",
		"",
		"### Key Features and Functionality",
		"",
		"| Feature                  | Description                                                                                   |",
		"|--------------------------|-----------------------------------------------------------------------------------------------|",
		"| HTTP Method Selection    | Choose methods like GET, POST, PUT, DELETE, PATCH, or any HttpMethod plugin type at run time. |",
		"| URL Configuration        | Set the request URL dynamically during execution.                                             |",
		"| Custom Headers & Payload | Define headers, body content, and query parameters for each request.                          |",
		"",
		"### Usages in RPA",
		"",
		"| Use Case                | Description                                                 |",
		"|-------------------------|-------------------------------------------------------------|",
		"| Web Service Integration | Let robots connect to external APIs to get or send data.    |",
		"| Workflow Orchestration  | Use API calls alongside other automation steps in one flow. |",
		"",
		"### Usages in Automation Testing",
		"",
		"| Use Case          | Description                                                         |",
		"|-------------------|---------------------------------------------------------------------|",
		"| API Testing       | Send different requests to check API behavior and validate results. |",
		"| Data Verification | Fetch data from services and compare it with expected values.       |",
		"| Load Testing      | Send many requests at once to see how the system handles traffic.   |"
	],
	"examples": [
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Unsupported or missing JSONPath/XPath expression",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP GET request is sent to `https://api.example.com/v1/items/search?category=Electronics` and the full JSON response is returned.",
					"notes": "Sends an HTTP GET request and returns the raw response.",
					"test_case": "send_http_request_get_full_response",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: GET Full Response",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` using the `SendHttpRequest` plugin to retrieve the full JSON response.",
				"After execution, the entire JSON payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Method:Get}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `resultCount` field is extracted from the JSON response and returned as a numeric value.",
					"notes": "Applies a regex to the JSON response body to extract the `resultCount` value.",
					"test_case": "send_http_request_get_resultcount_with_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract resultCount via Regex",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` and apply the regex `(?<=\\\"resultCount\\\":)\\d+` to the response body to extract the `resultCount` value.",
				"After execution, the extracted count is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Method:Get}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"resultCount\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid onElement expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The first `<Item>` element with `stockAvailable='true'` is returned.",
					"notes": "Selects the first in-stock item element from the XML response.",
					"test_case": "send_http_request_get_first_instock_xml_element",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First In-Stock XML Element",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` and use the XPath `(//Item[@stockAvailable='true'])[1]` to select the first in-stock `<Item>` element from the XML response.",
				"After execution, that element is available for further attribute or content extraction."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Method:Get}}",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid onElement expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `name` attribute of the first in-stock `<Item>` element is extracted.",
					"notes": "Applies a regex to the XML element string to extract the item name.",
					"test_case": "send_http_request_get_first_instock_name_with_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract In-Stock Item Name via Regex",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics`, select the first in-stock `<Item>` element using XPath `(//Item[@stockAvailable='true'])[1]`, and apply the regex `(?<=name=\")[^\"]+` to extract its `name` attribute.",
				"After execution, the extracted name is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Method:Get}}",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=name=\")[^\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching items in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "All items with `stockAvailable==true` are returned as a JSON array.",
					"notes": "Selects in-stock items using a JSONPath filter.",
					"test_case": "send_http_request_get_all_instock_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract All In-Stock Items via JSONPath",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` and use the JSONPath `$.items[?(@.stockAvailable==true)]` to select all in-stock items from the JSON response.",
				"After execution, the filtered array is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Method:Get}}",
				"onElement": "$.items[?(@.stockAvailable==true)]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Index out of bounds",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The first item in the `items` array is returned.",
					"notes": "Selects the first item using JSONPath index.",
					"test_case": "send_http_request_get_first_item_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First Item via JSONPath",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` and use the JSONPath `$.items[0]` to select the first item from the JSON response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Method:Get}}",
				"onElement": "$.items[0]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Missing onAttribute argument",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `price` attribute of the first in-stock `<Item>` element is returned.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_get_first_instock_price_attribute",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First In-Stock Item Price Attribute",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics`, select the first in-stock `<Item>` element using XPath `(//Item[@stockAvailable='true'])[1]`, and extract its `price` attribute.",
				"After execution, the price value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Method:Get}}",
				"onAttribute": "price",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` attribute of the first in-stock `<Item>` element is extracted.",
					"notes": "Applies a regex to an attribute value to extract digits.",
					"test_case": "send_http_request_get_first_instock_id_with_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First In-Stock Item ID via Regex",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics`, select the first in-stock `<Item>` element using XPath `(//Item[@stockAvailable='true'])[1]`, and apply the regex `\\d+` to its `id` attribute to extract digits.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Method:Get}}",
				"onAttribute": "id",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest",
				"regularExpression": "\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP GET request with Basic authentication is sent to `https://api.example.com/v1/items/search?category=Electronics` and the full JSON response is returned.",
					"notes": "Sends an authenticated HTTP GET request and returns the raw response.",
					"test_case": "send_http_request_get_full_response_with_header",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: GET Full Response with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` using the `SendHttpRequest` plugin with the header `Authorization: Basic username:password` to retrieve the full JSON response.",
				"After execution, the entire JSON payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Basic username:password --Method:Get}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `resultCount` field is extracted from the authenticated JSON response and returned as a numeric value.",
					"notes": "Applies a regex to the JSON response body to extract the `resultCount` value.",
					"test_case": "send_http_request_get_resultcount_with_regex_and_header",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract resultCount via Regex with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with the header `Authorization: Basic username:password` and apply the regex `(?<=\\\"resultCount\\\":)\\d+` to the response body to extract the `resultCount` value.",
				"After execution, the extracted count is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Basic username:password --Method:Get}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"resultCount\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid onElement expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The first `<Item>` element with `stockAvailable='true'` is returned from the authenticated XML response.",
					"notes": "Selects the first in-stock item element from the XML response.",
					"test_case": "send_http_request_get_first_instock_xml_element_with_header",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First In-Stock XML Element with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with the header `Authorization: Basic username:password` and use the XPath `(//Item[@stockAvailable='true'])[1]` to select the first in-stock `<Item>` element from the XML response.",
				"After execution, that element is available for further attribute or content extraction."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Basic username:password --Method:Get}}",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid onElement expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `name` attribute of the first in-stock `<Item>` element is extracted from the authenticated XML response.",
					"notes": "Applies a regex to the XML element string to extract the item name.",
					"test_case": "send_http_request_get_first_instock_name_with_regex_and_header",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract In-Stock Item Name via Regex with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with the header `Authorization: Basic username:password`, select the first in-stock `<Item>` element using XPath `(//Item[@stockAvailable='true'])[1]`, and apply the regex `(?<=name=\")[^\"]+` to extract its `name` attribute.",
				"After execution, the extracted name is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Basic username:password --Method:Get}}",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=name=\")[^\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching items in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "All items with `stockAvailable==true` are returned as a JSON array from the authenticated response.",
					"notes": "Selects in-stock items using a JSONPath filter.",
					"test_case": "send_http_request_get_all_instock_jsonpath_with_header",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract All In-Stock Items via JSONPath with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with the header `Authorization: Basic username:password` and use the JSONPath `$.items[?(@.stockAvailable==true)]` to select all in-stock items from the JSON response.",
				"After execution, the filtered array is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Basic username:password --Method:Get}}",
				"onElement": "$.items[?(@.stockAvailable==true)]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Index out of bounds",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The first item in the `items` array is returned from the authenticated JSON response.",
					"notes": "Selects the first item using JSONPath index.",
					"test_case": "send_http_request_get_first_item_jsonpath_with_header",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First Item via JSONPath with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with the header `Authorization: Basic username:password` and use the JSONPath `$.items[0]` to select the first item from the JSON response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Basic username:password --Method:Get}}",
				"onElement": "$.items[0]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Missing onAttribute argument",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `price` attribute of the first in-stock `<Item>` element is returned from the authenticated XML response.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_get_first_instock_price_attribute_with_header",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First In-Stock Item Price Attribute with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with the header `Authorization: Basic username:password`, select the first in-stock `<Item>` element using XPath `(//Item[@stockAvailable='true'])[1]`, and extract its `price` attribute.",
				"After execution, the price value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Basic username:password --Method:Get}}",
				"onAttribute": "price",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` attribute of the first in-stock `<Item>` element is extracted from the authenticated XML response.",
					"notes": "Applies a regex to an attribute value to extract digits.",
					"test_case": "send_http_request_get_first_instock_id_with_regex_and_header",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First In-Stock Item ID via Regex with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with the header `Authorization: Basic username:password`, select the first in-stock `<Item>` element using XPath `(//Item[@stockAvailable='true'])[1]`, and apply the regex `\\d+` to its `id` attribute to extract digits.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Basic username:password --Method:Get}}",
				"onAttribute": "id",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest",
				"regularExpression": "\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP GET request with Bearer token and custom UserAgent header is sent to `https://api.example.com/v1/items/search?category=Electronics` and the full JSON response is returned.",
					"notes": "Sends an authenticated HTTP GET request with multiple headers and returns the raw response.",
					"test_case": "send_http_request_get_full_response_with_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: GET Full Response with Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` using the `SendHttpRequest` plugin with headers `Authorization: Bearer YourAccessToken` and `UserAgent: MyCustomUserAgent` to retrieve the full JSON response.",
				"After execution, the entire JSON payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method:Get}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `resultCount` field is extracted from the authenticated JSON response and returned as a numeric value.",
					"notes": "Applies a regex to the JSON response body to extract the `resultCount` value.",
					"test_case": "send_http_request_get_resultcount_with_regex_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract resultCount via Regex with Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with headers `Authorization: Bearer YourAccessToken` and `UserAgent: MyCustomUserAgent`, and apply the regex `(?<=\\\"resultCount\\\":)\\d+` to the response body to extract the `resultCount` value.",
				"After execution, the extracted count is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method:Get}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"resultCount\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid onElement expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The first `<Item>` element with `stockAvailable='true'` is returned from the authenticated XML response.",
					"notes": "Selects the first in-stock item element from the XML response.",
					"test_case": "send_http_request_get_first_instock_xml_element_with_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First In-Stock XML Element with Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with headers `Authorization: Bearer YourAccessToken` and `UserAgent: MyCustomUserAgent`, and use the XPath `(//Item[@stockAvailable='true'])[1]` to select the first in-stock `<Item>` element from the XML response.",
				"After execution, that element is available for further attribute or content extraction."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method:Get}}",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid onElement expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `name` attribute of the first in-stock `<Item>` element is extracted from the authenticated XML response.",
					"notes": "Applies a regex to the XML element string to extract the item name.",
					"test_case": "send_http_request_get_first_instock_name_with_regex_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract In-Stock Item Name via Regex with Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with headers `Authorization: Bearer YourAccessToken` and `UserAgent: MyCustomUserAgent`, select the first in-stock `<Item>` element using XPath `(//Item[@stockAvailable='true'])[1]`, and apply the regex `(?<=name=\")[^\"]+` to extract its `name` attribute.",
				"After execution, the extracted name is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method:Get}}",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=name=\")[^\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching items in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "All items with `stockAvailable==true` are returned as a JSON array from the authenticated response.",
					"notes": "Selects in-stock items using a JSONPath filter.",
					"test_case": "send_http_request_get_all_instock_jsonpath_with_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract All In-Stock Items via JSONPath with Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with headers `Authorization: Bearer YourAccessToken` and `UserAgent: MyCustomUserAgent`, and use the JSONPath `$.items[?(@.stockAvailable==true)]` to select all in-stock items from the JSON response.",
				"After execution, the filtered array is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method:Get}}",
				"onElement": "$.items[?(@.stockAvailable==true)]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Index out of bounds",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The first item in the `items` array is returned from the authenticated JSON response.",
					"notes": "Selects the first item using JSONPath index.",
					"test_case": "send_http_request_get_first_item_jsonpath_with_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First Item via JSONPath with Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with headers `Authorization: Bearer YourAccessToken` and `UserAgent: MyCustomUserAgent`, and use the JSONPath `$.items[0]` to select the first item from the JSON response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method:Get}}",
				"onElement": "$.items[0]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Missing onAttribute argument",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `price` attribute of the first in-stock `<Item>` element is returned from the authenticated XML response.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_get_first_instock_price_attribute_with_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First In-Stock Item Price Attribute with Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with headers `Authorization: Bearer YourAccessToken` and `UserAgent: MyCustomUserAgent`, select the first in-stock `<Item>` element using XPath `(//Item[@stockAvailable='true'])[1]`, and extract its `price` attribute.",
				"After execution, the price value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method:Get}}",
				"onAttribute": "price",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` attribute of the first in-stock `<Item>` element is extracted from the authenticated XML response.",
					"notes": "Applies a regex to an attribute value to extract digits.",
					"test_case": "send_http_request_get_first_instock_id_with_regex_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First In-Stock Item ID via Regex with Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP GET request to `https://api.example.com/v1/items/search?category=Electronics` with headers `Authorization: Bearer YourAccessToken` and `UserAgent: MyCustomUserAgent`, select the first in-stock `<Item>` element using XPath `(//Item[@stockAvailable='true'])[1]`, and apply the regex `\\d+` to its `id` attribute to extract digits.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/search?category=Electronics --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method:Get}}",
				"onAttribute": "id",
				"onElement": "(//Item[@stockAvailable='true'])[1]",
				"pluginName": "SendHttpRequest",
				"regularExpression": "\\d+"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP POST request with the JSON body is sent to `https://api.example.com/v1/items` and the full JSON response is returned.",
					"notes": "Sends an HTTP POST request with a JSON body and returns the raw response.",
					"test_case": "send_http_request_post_full_response_with_body",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST Full Response with JSON Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` to retrieve the full JSON response.",
				"After execution, the entire JSON payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `message` field is extracted from the JSON response and returned as text.",
					"notes": "Applies a regex to the JSON response body to extract the `message` value.",
					"test_case": "send_http_request_post_message_with_regex",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract message via Regex with JSON Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and apply the regex `(?<=\"message\":\")[^\"]+` to the response body to extract the `message` value.",
				"After execution, the extracted message is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\"message\":\")[^\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `updatedItem` object is selected from the JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath.",
					"test_case": "send_http_request_post_select_updateditem_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath with JSON Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and use the JSONPath `$.updatedItem` to select the `updatedItem` object from the response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` field of `updatedItem` is extracted.",
					"notes": "Applies a regex to the JSON response to extract the `id` value.",
					"test_case": "send_http_request_post_id_with_regex_on_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex with JSON Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}`, select the `updatedItem` object using JSONPath `$.updatedItem`, and apply the regex `(?<=\"id\":)\\d+` to extract its `id` value.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\"id\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is returned.",
					"notes": "Selects the `<Status>` element from XML response.",
					"test_case": "send_http_request_post_status_text_xpath",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via XPath with JSON Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and use the XPath `//Status` to select the `<Status>` element text from the XML response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is extracted via regex.",
					"notes": "Applies a regex to the XML element text to extract content.",
					"test_case": "send_http_request_post_status_text_with_regex_xpath",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via Regex with JSON Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}`, select the `<Status>` element using XPath `//Status`, and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is returned.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_post_response_status_attribute",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute with JSON Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}`, select the `<Response>` element using XPath `//Response`, and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is extracted via regex.",
					"notes": "Applies a regex to an attribute value to extract 'success' or 'failure'.",
					"test_case": "send_http_request_post_response_status_with_regex_and_body",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status via Regex with JSON Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}`, select the `<Response>` element using XPath `//Response`, and apply the regex `success|failure` to its `status` attribute.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|failure"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP POST request with JSON body and Basic authentication header is sent to `https://api.example.com/v1/items` and the full JSON response is returned.",
					"notes": "Sends an HTTP POST request with a JSON body and returns the raw response.",
					"test_case": "send_http_request_post_full_response_with_body_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST Full Response with JSON Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and the header `Authorization: Basic username:password` to retrieve the full JSON response.",
				"After execution, the entire JSON payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `message` field is extracted from the authenticated JSON response and returned as text.",
					"notes": "Applies a regex to the JSON response body to extract the `message` value.",
					"test_case": "send_http_request_post_message_with_regex_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract message via Regex with JSON Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and header `Authorization: Basic username:password`, then apply the regex `(?<=\"message\":\")[^\"]+` to the response body to extract the `message` value.",
				"After execution, the extracted message is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\"message\":\")[^\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `updatedItem` object is selected from the authenticated JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath.",
					"test_case": "send_http_request_post_select_updateditem_jsonpath_with_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath with JSON Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and header `Authorization: Basic username:password`, then use the JSONPath `$.updatedItem` to select the `updatedItem` object from the response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` field of `updatedItem` is extracted from the authenticated JSON response.",
					"notes": "Applies a regex to the JSON response to extract the `id` value.",
					"test_case": "send_http_request_post_id_with_regex_on_jsonpath_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex with JSON Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and header `Authorization: Basic username:password`, select the `updatedItem` object using JSONPath `$.updatedItem`, and apply the regex `(?<=\"id\":)\\d+` to extract its `id` value.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\"id\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is returned from the authenticated XML response.",
					"notes": "Selects the `<Status>` element from the XML response.",
					"test_case": "send_http_request_post_status_text_xpath_with_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via XPath with JSON Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and header `Authorization: Basic username:password`, then use the XPath `//Status` to select the `<Status>` element text from the XML response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is extracted via regex from the authenticated XML response.",
					"notes": "Applies a regex to the XML element text to extract content.",
					"test_case": "send_http_request_post_status_text_with_regex_xpath_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via Regex with JSON Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and header `Authorization: Basic username:password`, then select the `<Status>` element using XPath `//Status` and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is returned from the authenticated XML response.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_post_response_status_attribute_with_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute with JSON Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and header `Authorization: Basic username:password`, then select the `<Response>` element using XPath `//Response` and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is extracted via regex from the authenticated XML response.",
					"notes": "Applies a regex to an attribute value to extract 'success' or 'failure'.",
					"test_case": "send_http_request_post_response_status_with_regex_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status via Regex with JSON Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and header `Authorization: Basic username:password`, then select the `<Response>` element using XPath `//Response` and apply the regex `success|failure` to its `status` attribute.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|failure"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP POST request with JSON body and two headers is sent to `https://api.example.com/v1/items` and the full JSON response is returned.",
					"notes": "Sends an HTTP POST request with a JSON body and multiple headers, returning the raw response.",
					"test_case": "send_http_request_post_full_response_with_body_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST Full Response with JSON Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent` to retrieve the full JSON response.",
				"After execution, the entire JSON payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `message` field is extracted from the authenticated JSON response and returned as text.",
					"notes": "Applies a regex to the JSON response body to extract the `message` value.",
					"test_case": "send_http_request_post_message_with_regex_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract message via Regex with JSON Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then apply the regex `(?<=\"message\":\")[^\"]+` to the response body to extract the `message` value.",
				"After execution, the extracted message is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\"message\":\")[^\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `updatedItem` object is selected from the authenticated JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath.",
					"test_case": "send_http_request_post_select_updateditem_jsonpath_with_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath with JSON Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then use the JSONPath `$.updatedItem` to select the `updatedItem` object from the response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` field of `updatedItem` is extracted from the authenticated JSON response.",
					"notes": "Applies a regex to the JSON response to extract the `id` value.",
					"test_case": "send_http_request_post_id_with_regex_on_jsonpath_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex with JSON Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, select the `updatedItem` object using JSONPath `$.updatedItem`, and apply the regex `(?<=\"id\":)\\d+` to extract its `id` value.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\"id\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is returned from the authenticated XML response.",
					"notes": "Selects the `<Status>` element from the XML response.",
					"test_case": "send_http_request_post_status_text_xpath_with_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via XPath with JSON Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then use the XPath `//Status` to select the `<Status>` element text from the XML response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is extracted via regex from the authenticated XML response.",
					"notes": "Applies a regex to the XML element text to extract content.",
					"test_case": "send_http_request_post_status_text_with_regex_xpath_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via Regex with JSON Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Status>` element using XPath `//Status` and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is returned from the authenticated XML response.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_post_response_status_attribute_with_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute with JSON Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Response>` element using XPath `//Response` and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is extracted via regex from the authenticated XML response.",
					"notes": "Applies a regex to an attribute value to extract 'success' or 'failure'.",
					"test_case": "send_http_request_post_response_status_with_regex_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status via Regex with JSON Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with the JSON body `{\"name\":\"Premium Widget\",\"price\":99.99}` and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Response>` element using XPath `//Response` and apply the regex `success|failure` to its `status` attribute.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|failure"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP POST request with plain-text body and text/plain content type is sent to `https://api.example.com/v1/items` and the full response is returned.",
					"notes": "Sends an HTTP POST request with a text/plain body and returns the raw response.",
					"test_case": "send_http_request_post_full_response_with_plain_body",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST Full Response with Text/Plain Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with content type `text/plain` and the body `Name=PremiumWidget;Price=99.99` to retrieve the full response.",
				"After execution, the raw response payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The 3-digit status code is extracted from the response via regex.",
					"notes": "Applies a regex to the response to extract a status code.",
					"test_case": "send_http_request_post_status_code_with_regex_plain_body",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Code via Regex with Text/Plain Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain` and the body `Name=PremiumWidget;Price=99.99`, then apply the regex `(?<=Status: )\\d{3}` to extract a three-digit status code from the response.",
				"After execution, the extracted code is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `updatedItem` object is selected from the JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath.",
					"test_case": "send_http_request_post_select_updateditem_jsonpath_plain_body",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath with Text/Plain Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain` and the body `Name=PremiumWidget;Price=99.99;Stock=150`, then use the JSONPath `$.updatedItem` to select the `updatedItem` object from the response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` field of `updatedItem` is extracted via regex.",
					"notes": "Applies a regex to the JSONPath-selected object to extract the `id` value.",
					"test_case": "send_http_request_post_id_with_regex_on_jsonpath_plain_body",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex with Text/Plain Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain` and the body `Name=PremiumWidget;Price=99.99;Stock=150`, select the `updatedItem` object using JSONPath `$.updatedItem`, and apply the regex `(?<=\\\"id\\\":)\\d+` to extract its `id` value.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is returned from the XML response.",
					"notes": "Selects the `<Status>` element using XPath.",
					"test_case": "send_http_request_post_status_text_xpath_plain_body",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via XPath with Text/Plain Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain` and the body `Name=PremiumWidget;Price=99.99;Stock=150`, then use the XPath `//Status` to select the `<Status>` element text from the response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is extracted via regex from the XML response.",
					"notes": "Applies a regex to the XPath-selected element to extract its text.",
					"test_case": "send_http_request_post_status_text_with_regex_xpath_plain_body",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via Regex with Text/Plain Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain` and the body `Name=PremiumWidget;Price=99.99;Stock=150`, select the `<Status>` element using XPath `//Status`, and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is returned from the XML response.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_post_response_status_attribute_plain_body",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute with Text/Plain Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain` and the body `Name=PremiumWidget;Price=99.99;Stock=150`, then select the `<Response>` element using XPath `//Response` and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is extracted via regex from the XML response.",
					"notes": "Applies a regex to an attribute value to extract 'success' or 'error'.",
					"test_case": "send_http_request_post_response_status_with_regex_plain_body",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status via Regex with Text/Plain Body",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain` and the body `Name=PremiumWidget;Price=99.99;Stock=150`, then select the `<Response>` element using XPath `//Response` and apply the regex `success|error` to its `status` attribute.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP POST request with text/plain body and Basic authentication header is sent to `https://api.example.com/v1/items` and the full response is returned.",
					"notes": "Sends an HTTP POST request with a text/plain body and returns the raw response.",
					"test_case": "send_http_request_post_full_response_with_plain_body_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST Full Response with Text/Plain Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99`, and the header `Authorization: Basic username:password` to retrieve the full response.",
				"After execution, the raw response payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "A three-digit status code is extracted from the response via regex.",
					"notes": "Applies a regex to the response to extract the status code.",
					"test_case": "send_http_request_post_status_code_with_regex_plain_body_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Code via Regex with Text/Plain Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99`, and the header `Authorization: Basic username:password`, then apply the regex `(?<=Status: )\\d{3}` to extract a three-digit status code from the response.",
				"After execution, the extracted code is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `updatedItem` object is selected from the JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath.",
					"test_case": "send_http_request_post_select_updateditem_jsonpath_plain_body_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath with Text/Plain Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and the header `Authorization: Basic username:password`, then use the JSONPath `$.updatedItem` to select the `updatedItem` object from the response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` field of `updatedItem` is extracted via regex.",
					"notes": "Applies a regex to the JSONPath-selected object to extract the `id` value.",
					"test_case": "send_http_request_post_id_with_regex_on_jsonpath_plain_body_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex with Text/Plain Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and the header `Authorization: Basic username:password`, select the `updatedItem` object using JSONPath `$.updatedItem`, and apply the regex `(?<=\\\"id\\\":)\\d+` to extract its `id` value.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is returned from the XML response.",
					"notes": "Selects the `<Status>` element using XPath.",
					"test_case": "send_http_request_post_status_text_xpath_plain_body_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via XPath with Text/Plain Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and the header `Authorization: Basic username:password`, then use the XPath `//Status` to select the `<Status>` element text from the response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is extracted via regex from the XML response.",
					"notes": "Applies a regex to the XPath-selected element to extract its text.",
					"test_case": "send_http_request_post_status_text_with_regex_xpath_plain_body_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via Regex with Text/Plain Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and the header `Authorization: Basic username:password`, then select the `<Status>` element using XPath `//Status` and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is returned from the XML response.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_post_response_status_attribute_plain_body_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute with Text/Plain Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and the header `Authorization: Basic username:password`, then select the `<Response>` element using XPath `//Response` and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is extracted via regex from the XML response.",
					"notes": "Applies a regex to an attribute value to extract 'success' or 'error'.",
					"test_case": "send_http_request_post_response_status_with_regex_plain_body_and_header",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status via Regex with Text/Plain Body and Header",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and the header `Authorization: Basic username:password`, then select the `<Response>` element using XPath `//Response` and apply the regex `success|error` to its `status` attribute.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP POST request with a text/plain body and two headers is sent to `https://api.example.com/v1/items` and the raw response is returned.",
					"notes": "Sends an HTTP POST request with a text/plain body and multiple headers, returning the raw response.",
					"test_case": "send_http_request_post_full_response_with_plain_body_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST Full Response with Text/Plain Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent` to retrieve the full response.",
				"After execution, the raw response payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "A three-digit status code is extracted from the response via regex.",
					"notes": "Applies a regex to the response to extract the status code.",
					"test_case": "send_http_request_post_status_code_with_regex_plain_body_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Code via Regex with Text/Plain Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then apply the regex `(?<=Status: )\\d{3}` to extract a three-digit status code from the response.",
				"After execution, the extracted code is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `updatedItem` object is selected from the JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath.",
					"test_case": "send_http_request_post_select_updateditem_jsonpath_plain_body_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath with Text/Plain Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then use the JSONPath `$.updatedItem` to select the `updatedItem` object from the response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` field of `updatedItem` is extracted via regex.",
					"notes": "Applies a regex to the JSONPath-selected object to extract the `id` value.",
					"test_case": "send_http_request_post_id_with_regex_on_jsonpath_plain_body_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex with Text/Plain Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, select the `updatedItem` object using JSONPath `$.updatedItem`, and apply the regex `(?<=\\\"id\\\":)\\d+` to extract its `id` value.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is returned from the XML response.",
					"notes": "Selects the `<Status>` element using XPath.",
					"test_case": "send_http_request_post_status_text_xpath_plain_body_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via XPath with Text/Plain Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then use the XPath `//Status` to select the `<Status>` element text from the response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is extracted via regex from the XML response.",
					"notes": "Applies a regex to the XPath-selected element to extract its text.",
					"test_case": "send_http_request_post_status_text_with_regex_xpath_plain_body_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via Regex with Text/Plain Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Status>` element using XPath `//Status` and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is returned from the XML response.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_post_response_status_attribute_plain_body_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute with Text/Plain Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Response>` element using XPath `//Response` and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is extracted via regex from the XML response.",
					"notes": "Applies a regex to an attribute value to extract 'success' or 'error'.",
					"test_case": "send_http_request_post_response_status_with_regex_plain_body_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status via Regex with Text/Plain Body and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Response>` element using XPath `//Response` and apply the regex `success|error` to its `status` attribute.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP POST request with text/plain body and ASCII encoding is sent to `https://api.example.com/v1/items` and the full response is returned.",
					"notes": "Sends an HTTP POST request with a text/plain body and ASCII encoding, returning the raw response.",
					"test_case": "send_http_request_post_plain_body_ascii",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST Full Response with Text/Plain Body and ASCII Encoding",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99`, and encoding `ASCII` to retrieve the full response.",
				"After execution, the raw response payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Encoding:ASCII --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "A three-digit status code is extracted via regex from the plain-text response.",
					"notes": "Applies a regex to the response to extract a three-digit status code.",
					"test_case": "send_http_request_post_status_code_regex_plain_body_ascii",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Code via Regex with Text/Plain Body and ASCII Encoding",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99`, and encoding `ASCII`, then apply the regex `(?<=Status: )\\d{3}` to extract the status code from the response.",
				"After execution, the extracted code is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Encoding:ASCII --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `updatedItem` object is selected from the JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath.",
					"test_case": "send_http_request_post_select_updateditem_jsonpath_plain_body_ascii",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath with Text/Plain Body and ASCII Encoding",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and encoding `ASCII`, then use the JSONPath `$.updatedItem` to select the `updatedItem` object from the response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` field of `updatedItem` is extracted via regex.",
					"notes": "Applies a regex to the JSONPath-selected object to extract the `id` value.",
					"test_case": "send_http_request_post_id_regex_jsonpath_plain_body_ascii",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex with Text/Plain Body and ASCII Encoding",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and encoding `ASCII`, select the `updatedItem` object using JSONPath `$.updatedItem`, and apply the regex `(?<=\\\"id\\\":)\\d+` to extract its `id` value.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is returned from the XML response.",
					"notes": "Selects the `<Status>` element using XPath.",
					"test_case": "send_http_request_post_status_text_xpath_plain_body_ascii",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via XPath with Text/Plain Body and ASCII Encoding",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and encoding `ASCII`, then use the XPath `//Status` to select the `<Status>` element text from the response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is extracted via regex from the XML response.",
					"notes": "Applies a regex to the XPath-selected element to extract its text.",
					"test_case": "send_http_request_post_status_text_regex_xpath_plain_body_ascii",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via Regex with Text/Plain Body and ASCII Encoding",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and encoding `ASCII`, then select the `<Status>` element using XPath `//Status` and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is returned from the XML response.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_post_response_status_attribute_plain_body_ascii",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute with Text/Plain Body and ASCII Encoding",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and encoding `ASCII`, then select the `<Response>` element using XPath `//Response` and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is extracted via regex from the XML response.",
					"notes": "Applies a regex to an attribute value to extract 'success' or 'error'.",
					"test_case": "send_http_request_post_response_status_regex_attribute_plain_body_ascii",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status via Regex with Text/Plain Body and ASCII Encoding",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, and encoding `ASCII`, then select the `<Response>` element using XPath `//Response` and apply the regex `success|error` to its `status` attribute.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP POST request with text/plain body, ASCII encoding, and two headers is sent to `https://api.example.com/v1/items` and the full response is returned.",
					"notes": "Sends an HTTP POST request with a text/plain body, ASCII encoding, and multiple headers, returning the raw response.",
					"test_case": "send_http_request_post_full_response_with_plain_body_ascii_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST Full Response with Text/Plain Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent` to retrieve the full response.",
				"After execution, the raw response payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "A three-digit status code is extracted via regex from the plain-text response.",
					"notes": "Applies a regex to the response to extract a three-digit status code.",
					"test_case": "send_http_request_post_status_code_with_regex_plain_body_ascii_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Code via Regex with Text/Plain Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then apply the regex `(?<=Status: )\\d{3}` to extract the status code from the response.",
				"After execution, the extracted code is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `updatedItem` object is selected from the JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath.",
					"test_case": "send_http_request_post_select_updateditem_jsonpath_plain_body_ascii_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath with Text/Plain Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then use the JSONPath `$.updatedItem` to select the `updatedItem` object from the response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` field of `updatedItem` is extracted via regex.",
					"notes": "Applies a regex to the JSONPath-selected object to extract the `id` value.",
					"test_case": "send_http_request_post_id_with_regex_on_jsonpath_plain_body_ascii_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex with Text/Plain Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, select the `updatedItem` object using JSONPath `$.updatedItem`, and apply the regex `(?<=\\\"id\\\":)\\d+` to extract its `id` value.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is returned from the XML response.",
					"notes": "Selects the `<Status>` element using XPath.",
					"test_case": "send_http_request_post_status_text_xpath_plain_body_ascii_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via XPath with Text/Plain Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then use the XPath `//Status` to select the `<Status>` element text from the response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is extracted via regex from the XML response.",
					"notes": "Applies a regex to the XPath-selected element to extract its text.",
					"test_case": "send_http_request_post_status_text_regex_xpath_plain_body_ascii_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Text via Regex with Text/Plain Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Status>` element using XPath `//Status` and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is returned from the XML response.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_post_response_status_attribute_plain_body_ascii_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute with Text/Plain Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Response>` element using XPath `//Response` and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is extracted via regex from the XML response.",
					"notes": "Applies a regex to an attribute value to extract 'success' or 'error'.",
					"test_case": "send_http_request_post_response_status_with_regex_attribute_plain_body_ascii_and_multiple_headers",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status via Regex with Text/Plain Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Response>` element using XPath `//Response` and apply the regex `success|error` to its `status` attribute.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP POST with text/plain body, ASCII encoding, and Basic auth is sent and the full response is returned.",
					"notes": "Sends a text/plain POST with ASCII encoding and a Basic Authorization header.",
					"test_case": "send_http_request_post_plain_body_ascii_basicauth",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST Plain-Text Body with ASCII Encoding and Basic Auth",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99`, encoding `ASCII`, and the header `Authorization: Basic username:password` to retrieve the full response.",
				"After execution, the raw response payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "A three-digit status code is extracted via regex from the plain-text response.",
					"notes": "Applies a regex to extract the status code from a plain-text ASCII response.",
					"test_case": "send_http_request_post_status_code_regex_plain_body_ascii_basicauth",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Code via Regex from Plain-Text ASCII Response",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99`, encoding `ASCII`, and the header `Authorization: Basic username:password`, then apply the regex `(?<=Status: )\\d{3}` to extract the three-digit status code from the response.",
				"After execution, the extracted status code is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `updatedItem` object is selected from the JSON response via JSONPath.",
					"notes": "Selects the updated item using JSONPath.",
					"test_case": "send_http_request_post_select_updateditem_jsonpath_plain_body_ascii_basicauth",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath from Plain-Text ASCII Response",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and the header `Authorization: Basic username:password`, then use the JSONPath `$.updatedItem` to select the updated item object from the JSON response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` field is extracted from `updatedItem` via regex.",
					"notes": "Applies a regex to extract the `id` field from the updated item.",
					"test_case": "send_http_request_post_id_with_regex_jsonpath_plain_body_ascii_basicauth",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex from Plain-Text ASCII Response",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and the header `Authorization: Basic username:password`, then select the updated item via JSONPath `$.updatedItem` and apply the regex `(?<=\\\"id\\\":)\\d+` to extract its numeric ID.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is returned from the XML response.",
					"notes": "Selects the `<Status>` element using XPath.",
					"test_case": "send_http_request_post_status_text_xpath_plain_body_ascii_basicauth",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract <Status> Text via XPath from Plain-Text ASCII Response",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and the header `Authorization: Basic username:password`, then use the XPath `//Status` to select the `<Status>` element text from the XML response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is extracted via regex from the XML response.",
					"notes": "Applies a regex to extract the `<Status>` element text.",
					"test_case": "send_http_request_post_status_text_regex_xpath_plain_body_ascii_basicauth",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract <Status> Text via Regex from Plain-Text ASCII Response",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and the header `Authorization: Basic username:password`, then select the `<Status>` element using XPath `//Status` and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of `<Response>` is returned from the XML response.",
					"notes": "Extracts an attribute from the `<Response>` element.",
					"test_case": "send_http_request_post_response_status_attribute_plain_body_ascii_basicauth",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute from Plain-Text ASCII Response",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and the header `Authorization: Basic username:password`, then select the `<Response>` element using XPath `//Response` and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute is extracted and validated against `success|error`.",
					"notes": "Applies a regex to validate the `status` attribute of the `<Response>` element.",
					"test_case": "send_http_request_post_response_status_regex_attribute_plain_body_ascii_basicauth",
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract and Validate Response status via Regex from Plain-Text ASCII Response",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/plain`, the body `Name=PremiumWidget;Price=99.99;Stock=150`, encoding `ASCII`, and the header `Authorization: Basic username:password`, then select the `<Response>` element using XPath `//Response` and apply the regex `success|error` to its `status` attribute for validation.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_full_response_form_urlencoded_ascii_and_multiple_headers",
					"expected_result": "An HTTP POST with form-urlencoded fields, ASCII encoding, and multiple headers is sent and the full response is returned.",
					"notes": "Sends a form-urlencoded POST with ASCII encoding and multiple headers, returning the raw response.",
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Field argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"EncodingManagement",
					"FieldManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST Form-URLencoded Fields with ASCII Encoding and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with content type `x-www-form-urlencoded`, fields `Name=PremiumWidget` and `Price=99.99`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent` to retrieve the full response.",
				"After execution, the raw response payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_status_code_regex_form_urlencoded_ascii_and_multiple_headers",
					"expected_result": "A three-digit status code is extracted via regex from the plain-text response.",
					"notes": "Applies a regex to extract the status code from a form-urlencoded ASCII response.",
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Field argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"EncodingManagement",
					"FieldManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Code via Regex with Form-URLencoded Fields, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `x-www-form-urlencoded`, fields `Name=PremiumWidget` and `Price=99.99`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then apply the regex `(?<=Status: )\\d{3}` to extract the three-digit status code from the response.",
				"After execution, the extracted status code is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_select_updateditem_jsonpath_form_urlencoded_ascii_and_multiple_headers",
					"expected_result": "The `updatedItem` object is selected from the JSON response via JSONPath.",
					"notes": "Selects the updated item using JSONPath.",
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Field argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"EncodingManagement",
					"FieldManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath with Form-URLencoded Fields, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `x-www-form-urlencoded`, fields `Name=PremiumWidget`, `Price=99.99`, and `Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then use the JSONPath `$.updatedItem` to select the updated item object from the response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Field:Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_id_regex_jsonpath_form_urlencoded_ascii_and_multiple_headers",
					"expected_result": "The numeric `id` field is extracted from `updatedItem` via regex.",
					"notes": "Applies a regex to extract the `id` field from the updated item.",
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Field argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"EncodingManagement",
					"FieldManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex with Form-URLencoded Fields, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `x-www-form-urlencoded`, fields `Name=PremiumWidget`, `Price=99.99`, and `Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the updated item via JSONPath `$.updatedItem` and apply the regex `(?<=\\\"id\\\":)\\d+` to extract its numeric ID.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Field:Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_status_text_xpath_form_urlencoded_ascii_and_multiple_headers",
					"expected_result": "The `<Status>` element text is returned from the response.",
					"notes": "Selects the `<Status>` element using XPath.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Field argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"EncodingManagement",
					"FieldManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract <Status> Text via XPath with Form-URLencoded Fields, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `x-www-form-urlencoded`, fields `Name=PremiumWidget`, `Price=99.99`, and `Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then use the XPath `//Status` to select the `<Status>` element text from the response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Field:Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_status_text_regex_xpath_form_urlencoded_ascii_and_multiple_headers",
					"expected_result": "The `<Status>` element text is extracted via regex from the response.",
					"notes": "Applies a regex to extract the `<Status>` element text.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Field argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"EncodingManagement",
					"FieldManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract <Status> Text via Regex with Form-URLencoded Fields, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `x-www-form-urlencoded`, fields `Name=PremiumWidget`, `Price=99.99`, and `Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Status>` element using XPath `//Status` and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Field:Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_response_status_attribute_xpath_form_urlencoded_ascii_and_multiple_headers",
					"expected_result": "The `status` attribute of `<Response>` is returned from the response.",
					"notes": "Extracts an attribute from the `<Response>` element.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Field argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"EncodingManagement",
					"FieldManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute via XPath with Form-URLencoded Fields, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `x-www-form-urlencoded`, fields `Name=PremiumWidget`, `Price=99.99`, and `Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Response>` element using XPath `//Response` and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Field:Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_response_status_regex_attribute_xpath_form_urlencoded_ascii_and_multiple_headers",
					"expected_result": "The `status` attribute is extracted and validated against `success|error`.",
					"notes": "Applies a regex to validate the `status` attribute of `<Response>`.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Field argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"EncodingManagement",
					"FieldManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract and Validate Response status via Regex with Form-URLencoded Fields, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `x-www-form-urlencoded`, fields `Name=PremiumWidget`, `Price=99.99`, and `Stock=150`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Response>` element using XPath `//Response` and apply the regex `success|error` to its `status` attribute for validation.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Field:Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_full_response_xml_body_ascii_and_multiple_headers",
					"expected_result": "An HTTP POST with XML body, ASCII encoding, and multiple headers is sent and the full response is returned.",
					"notes": "Sends an XML POST with ASCII encoding and multiple headers, returning the raw response.",
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: POST XML Body with ASCII Encoding and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` using the `SendHttpRequest` plugin with content type `text/xml`, the body `<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item>`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent` to retrieve the full response.",
				"After execution, the raw response payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_status_code_regex_xml_body_ascii_and_multiple_headers",
					"expected_result": "A three-digit status code is extracted via regex from the plain-text response.",
					"notes": "Applies a regex to extract the status code from an XML ASCII response.",
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Status Code via Regex with XML Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/xml`, the body `<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item>`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then apply the regex `(?<=Status: )\\d{3}` to extract the three-digit status code from the response.",
				"After execution, the extracted status code is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_select_updateditem_jsonpath_xml_body_ascii_and_multiple_headers",
					"expected_result": "The `updatedItem` object is selected from the JSON response via JSONPath.",
					"notes": "Selects the updated item using JSONPath.",
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select updatedItem via JSONPath with XML Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/xml`, the body `<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item>`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then use the JSONPath `$.updatedItem` to select the updated item object from the JSON response.",
				"After execution, that object is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_id_regex_jsonpath_xml_body_ascii_and_multiple_headers",
					"expected_result": "The numeric `id` field is extracted from `updatedItem` via regex.",
					"notes": "Applies a regex to extract the `id` field from the updated item.",
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract updatedItem ID via Regex with XML Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/xml`, the body `<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item>`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the updated item via JSONPath `$.updatedItem` and apply the regex `(?<=\\\"id\\\":)\\d+` to extract its numeric ID.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_status_text_xpath_xml_body_ascii_and_multiple_headers",
					"expected_result": "The `<Status>` element text is returned from the response.",
					"notes": "Selects the `<Status>` element using XPath.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract <Status> Text via XPath with XML Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/xml`, the body `<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item>`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then use the XPath `//Status` to select the `<Status>` element text from the response.",
				"After execution, that text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_status_text_regex_xpath_xml_body_ascii_and_multiple_headers",
					"expected_result": "The `<Status>` element text is extracted via regex from the response.",
					"notes": "Applies a regex to extract the `<Status>` element text.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract <Status> Text via Regex with XML Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/xml`, the body `<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item>`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Status>` element using XPath `//Status` and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_response_status_attribute_xpath_xml_body_ascii_and_multiple_headers",
					"expected_result": "The `status` attribute of `<Response>` is returned from the response.",
					"notes": "Extracts an attribute from the `<Response>` element.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract Response status Attribute via XPath with XML Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/xml`, the body `<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item>`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Response>` element using XPath `//Response` and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_post_response_status_regex_attribute_xpath_xml_body_ascii_and_multiple_headers",
					"expected_result": "The `status` attribute is extracted and validated against `success|error`.",
					"notes": "Applies a regex to validate the `status` attribute of `<Response>`.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Body argument",
						"Missing --ContentType argument",
						"Missing --Encoding argument",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"BodyManagement",
					"EncodingManagement",
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract and Validate Response status via Regex with XML Body, ASCII Encoding, and Multiple Headers",
				"",
				"This example demonstrates how to send an HTTP POST request to `https://api.example.com/v1/items` with content type `text/xml`, the body `<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item>`, encoding `ASCII`, and headers `Authorization: Basic username:password` and `UserAgent: MyCustomUserAgent`, then select the `<Response>` element using XPath `//Response` and apply the regex `success|error` to its `status` attribute for validation.",
				"After execution, the extracted status is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Post}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_delete_full_response",
					"expected_result": "An HTTP DELETE request is sent and the full response is returned.",
					"notes": "Sends a DELETE request with no extra headers or body, returning the raw response.",
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: DELETE Full Response",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin with no additional parameters to retrieve the full response.",
				"After execution, the raw response payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Method:Delete}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_delete_message_regex",
					"expected_result": "The `message` field is extracted from the JSON DELETE response via regex.",
					"notes": "Applies a regex to extract the `message` field.",
					"edge_cases": [
						"Invalid URL format",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract message via Regex from DELETE Response",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin, then apply the regex `(?<=\\\"message\\\":\\\")[^\\\"]+` to extract the `message` field from the JSON response.",
				"After execution, the extracted message is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Method:Delete}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\"message\":\")[^\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_delete_status_xpath",
					"expected_result": "The `<Status>` element is returned from the DELETE response.",
					"notes": "Selects the `<Status>` element using XPath.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onElement argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Select <Status> Element via XPath from DELETE Response",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin, then use the XPath `//Status` to select the `<Status>` element from the XML response.",
				"After execution, that element is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Method:Delete}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_delete_status_regex_xpath",
					"expected_result": "The `<Status>` element text is extracted via regex from the DELETE response.",
					"notes": "Applies a regex to extract the `<Status>` element text.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onElement argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract <Status> Text via Regex from DELETE Response",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin, select the `<Status>` element via XPath `//Status`, and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Method:Delete}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_delete_deleted_results_jsonpath",
					"expected_result": "All items with `deleted==true` are returned as a JSON array.",
					"notes": "Selects deleted results using JSONPath.",
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in JSON response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select deleted Results via JSONPath from DELETE Response",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin, then use the JSONPath `$.results[?(@.deleted==true)]` to select all items marked as deleted in the JSON response.",
				"After execution, the filtered array is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Method:Delete}}",
				"onElement": "$.results[?(@.deleted==true)]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_delete_first_result_id_regex_jsonpath",
					"expected_result": "The `id` of the first result is extracted via regex.",
					"notes": "Applies a regex to extract the `id` from the first JSONPath result.",
					"edge_cases": [
						"Invalid JSONPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First Result ID via Regex from DELETE Response JSONPath",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin, select the first element via JSONPath `$.results[0]`, and apply the regex `(?<=\\\"id\\\":)\\d+` to extract its `id`.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Method:Delete}}",
				"onElement": "$.results[0]",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\"id\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"test_case": "send_http_request_delete_item_status_attribute_xpath",
					"expected_result": "The `status` attribute of the first `<Item>` element is returned.",
					"notes": "Extracts an attribute from an XML element.",
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing onElement argument",
						"Network error or timeout",
						"No matching element in XML response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract status Attribute from <Item> via XPath in DELETE Response",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin, then use the XPath `//Item` to select the first `<Item>` element and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Method:Delete}}",
				"onAttribute": "status",
				"onElement": "//Item",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XPath expression",
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing onElement argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` attribute of the first `<Item>` is extracted via regex.",
					"notes": "Applies a regex to extract digits from an attribute value.",
					"test_case": "send_http_request_delete_item_id_regex_attribute_xpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract <Item> ID via Regex from Attribute in DELETE Response",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin, then use the XPath `//Item` to select the first `<Item>` element and apply the regex `\\d+` to its `id` attribute to extract digits.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Method:Delete}}",
				"onAttribute": "id",
				"onElement": "//Item",
				"pluginName": "SendHttpRequest",
				"regularExpression": "\\d+"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Unsupported pluginName value",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "An HTTP DELETE with authorization header is sent and the full response is returned.",
					"notes": "Sends a DELETE with an Authorization header and returns the raw response.",
					"test_case": "send_http_request_delete_auth_full_response",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: DELETE Full Response with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin with header `Authorization: Basic username:password` to retrieve the full response.",
				"After execution, the raw response payload is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Basic username:password --Method:Delete}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `message` field is extracted via regex from the JSON DELETE response.",
					"notes": "Applies a regex to extract the `message` field.",
					"test_case": "send_http_request_delete_auth_message_regex",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract message via Regex from DELETE Response with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin with header `Authorization: Basic username:password`, then apply the regex `(?<=\\\"message\\\":\\\")[^\\\"]+` to extract the `message` field from the JSON response.",
				"After execution, the extracted message is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Basic username:password --Method:Delete}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\"message\":\")[^\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onElement argument",
						"Network error or timeout",
						"No matching element in response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element is selected from the DELETE response.",
					"notes": "Selects the `<Status>` element using XPath.",
					"test_case": "send_http_request_delete_auth_status_xpath",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Select <Status> Element via XPath from DELETE Response with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin with header `Authorization: Basic username:password`, then use the XPath `//Status` to select the `<Status>` element from the response.",
				"After execution, that element is available for subsequent extraction or validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Basic username:password --Method:Delete}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onElement argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `<Status>` element text is extracted via regex from the DELETE response.",
					"notes": "Applies a regex to extract the `<Status>` element text.",
					"test_case": "send_http_request_delete_auth_status_regex_xpath",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract <Status> Text via Regex from DELETE Response with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin with header `Authorization: Basic username:password`, select the `<Status>` element via XPath `//Status`, and apply the regex `(?<=<Status>).*?(?=</Status>)` to extract its text.",
				"After execution, the extracted text is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Basic username:password --Method:Delete}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Network error or timeout",
						"No matching path in response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "All items with `deleted==true` are returned as a JSON array.",
					"notes": "Selects deleted results using JSONPath.",
					"test_case": "send_http_request_delete_auth_deleted_results_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Select deleted Results via JSONPath from DELETE Response with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin with header `Authorization: Basic username:password`, then use the JSONPath `$.results[?(@.deleted==true)]` to select all items marked as deleted in the JSON response.",
				"After execution, the filtered array is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Basic username:password --Method:Delete}}",
				"onElement": "$.results[?(@.deleted==true)]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `id` of the first result is extracted via regex.",
					"notes": "Applies a regex to extract the `id` from the first JSONPath result.",
					"test_case": "send_http_request_delete_auth_first_result_id_regex_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"JsonPathExtraction",
					"RegexValidation",
					"ResponseElementExtraction",
					"SendHttpRequest"
				]
			},
			"description": [
				"### SendHttpRequest: Extract First Result ID via Regex from JSONPath in DELETE Response with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin with header `Authorization: Basic username:password`, select the first element via JSONPath `$.results[0]`, and apply the regex `(?<=\\\"id\\\":)\\d+` to extract its `id`.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Basic username:password --Method:Delete}}",
				"onElement": "$.results[0]",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\"id\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing onElement argument",
						"Network error or timeout",
						"No matching element in response",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The `status` attribute of the first `<Item>` element is returned.",
					"notes": "Extracts an attribute from an XML element.",
					"test_case": "send_http_request_delete_auth_item_status_attribute_xpath",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract status Attribute from <Item> via XPath in DELETE Response with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin with header `Authorization: Basic username:password`, then use the XPath `//Item` to select the first `<Item>` element and extract its `status` attribute.",
				"After execution, the attribute value is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Basic username:password --Method:Delete}}",
				"onAttribute": "status",
				"onElement": "//Item",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed CLI expression (missing `{{$` or `}}`)",
						"Missing --Header argument",
						"Missing --Method argument",
						"Missing --Url argument",
						"Missing onAttribute argument",
						"Missing onElement argument",
						"Missing regularExpression argument",
						"No regex match",
						"Network error or timeout",
						"Unexpected HTTP status code",
						"Version mismatch between plugin and engine"
					],
					"expected_result": "The numeric `id` attribute of the first `<Item>` is extracted via regex.",
					"notes": "Applies a regex to extract digits from an attribute value.",
					"test_case": "send_http_request_delete_auth_item_id_regex_attribute_xpath",
					"version": "1.0"
				},
				"labels": [
					"HeaderManagement",
					"HttpRequest",
					"RegexValidation",
					"ResponseAttributeExtraction",
					"SendHttpRequest",
					"XPathExtraction"
				]
			},
			"description": [
				"### SendHttpRequest: Extract <Item> ID via Regex from Attribute in DELETE Response with Authorization Header",
				"",
				"This example demonstrates how to send an HTTP DELETE request to `https://api.example.com/v1/items/567` using the `SendHttpRequest` plugin with header `Authorization: Basic username:password`, then use the XPath `//Item` to select the first `<Item>` element and apply the regex `\\d+` to its `id` attribute to extract digits.",
				"After execution, the extracted ID is available for subsequent actions."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Basic username:password --Method:Delete}}",
				"onAttribute": "id",
				"onElement": "//Item",
				"pluginName": "SendHttpRequest",
				"regularExpression": "\\d+"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"Network timeout",
						"Response too large",
						"Unexpected status code",
						"Unexpected whitespace in response"
					],
					"expected_result": "The full response body of the HTTP DELETE request is returned.",
					"notes": "Returns the complete response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "send_delete_full_response",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Delete Full Response",
				"",
				"This example returns the complete response body of an HTTP DELETE request to `https://api.example.com/v1/items/567` by specifying `onElement: responseBody` and using `--Method=DELETE` with the URL and headers.",
				"No extraction options are applied so downstream steps can process the raw response data."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method=DELETE}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in response"
					],
					"expected_result": "The `message` field value is extracted from the response body.",
					"notes": "Applies a regular expression to the full response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_message_from_body",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Message Field",
				"",
				"This example extracts the `message` field value by applying the regular expression `(?<=\\\"message\\\":\\\")[^\\\"]+` to the full response body with `onElement: responseBody`.",
				"Conversion to string ensures reliable pattern matching."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method=DELETE}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"message\\\":\\\")[^\\\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in element text",
						"XPath evaluation error"
					],
					"expected_result": "The text content of the `<Status>` element is returned.",
					"notes": "Locates `<Status>` via XPath and returns its inner text. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_text_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element Text",
				"",
				"This example retrieves the text content of the `<Status>` element from an XML response using XPath locator `//Status`.",
				"Extracted text enables validation or processing of status values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method=DELETE}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in element text"
					],
					"expected_result": "The inner text of the `<Status>` element is extracted after applying the regex.",
					"notes": "Applies a regular expression to the `<Status>` element text to extract core content without tags. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_content_with_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element Content with Regex",
				"",
				"This example retrieves the inner text of the `<Status>` element from an XML response using XPath locator `//Status` and applies the regular expression `(?<=<Status>).*?(?=</Status>)` to capture its content without surrounding tags.",
				"Regex improves performance by focusing on core content and conversion to string ensures reliable pattern matching."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method=DELETE}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"JSONPath evaluation error",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "All objects in the `results` array with `deleted` equal to true are returned.",
					"notes": "Selects JSON objects where `deleted` is true using JSONPath. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "select_deleted_items_via_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Select Deleted Items with JSONPath",
				"",
				"This example selects all objects in the `results` array with `deleted` equal to true from a JSON response using JSONPath locator `$.results[?(@.deleted==true)]`.",
				"This enables direct retrieval of relevant items for further processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method=DELETE}}",
				"onElement": "$.results[?(@.deleted==true)]",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"JSONPath evaluation error",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The `id` value is extracted from the first object in the `results` array.",
					"notes": "Selects the first object with JSONPath and applies a regular expression to its JSON string. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_id_from_first_result_with_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract ID from First Result with Regex",
				"",
				"This example selects the first object in the `results` array using JSONPath locator `$.results[0]` and applies the regular expression `(?<=\\\"id\\\":)\\d+` to its JSON string to extract the `id` value.",
				"Conversion to string ensures reliable pattern matching."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method=DELETE}}",
				"onElement": "$.results[0]",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in attribute value",
						"XPath evaluation error"
					],
					"expected_result": "The `status` attribute value is extracted from each `<Item>` element.",
					"notes": "Extracts the `status` attribute from `<Item>` elements using XPath. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_attribute_from_item",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Attribute from Item Element",
				"",
				"This example retrieves the value of the `status` attribute from each `<Item>` element in an XML response using XPath locator `//Item` with `onAttribute: status`.",
				"Extracted attribute values can drive validation or conditional logic."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method=DELETE}}",
				"onAttribute": "status",
				"onElement": "//Item",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in attribute value"
					],
					"expected_result": "The numeric portion of the `id` attribute is extracted from each `<Item>` element.",
					"notes": "Applies a regular expression to the `id` attribute text of `<Item>` elements. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_id_attribute_with_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Item ID Attribute with Regex",
				"",
				"This example retrieves the `id` attribute text from each `<Item>` element in an XML response using XPath locator `//Item` with `onAttribute: id` and applies the regular expression `\\d+` to capture numeric characters.",
				"Conversion to string ensures reliable pattern matching."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Header:Authorization=Bearer YourAccessToken --Header:UserAgent=MyCustomUserAgent --Method=DELETE}}",
				"onAttribute": "id",
				"onElement": "//Item",
				"pluginName": "SendHttpRequest",
				"regularExpression": "\\d+"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"Network timeout",
						"Response too large",
						"Unexpected status code",
						"Unexpected whitespace in response"
					],
					"expected_result": "The full response body of the HTTP PUT request is returned.",
					"notes": "Returns the complete response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "return_put_full_response",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item Full Response",
				"",
				"This example returns the complete response body of an HTTP PUT request to `https://api.example.com/v1/items/567` using `--Method=PUT` and `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}` with `onElement: responseBody`, allowing downstream steps to process raw data."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method=PUT}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in response"
					],
					"expected_result": "The `message` field is extracted from the response body.",
					"notes": "Applies a regular expression to the full response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_message_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Message via Regex",
				"",
				"This example applies the regular expression `(?<=\\\"message\\\":\\\")[^\\\"]+` to the full response body using `onElement: responseBody` to extract the `message` field reliably without parsing the entire JSON."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method=PUT}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"message\\\":\\\")[^\\\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"JSONPath evaluation error",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The `updatedItem` object is returned from the JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "select_updated_item_via_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Select Updated Item via JSONPath",
				"",
				"This example locates the `updatedItem` object in the JSON response using JSONPath locator `$.updatedItem` with `onElement: $.updatedItem`, enabling direct access to the updated data for further processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method=PUT}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"JSONPath evaluation error",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The `id` value is extracted from the `updatedItem` object.",
					"notes": "Selects `updatedItem` via JSONPath and applies a regular expression to its JSON string. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_updated_item_id_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Updated Item ID via Regex",
				"",
				"This example selects `updatedItem` using JSONPath locator `$.updatedItem` with `onElement: $.updatedItem` and applies the regular expression `(?<=\\\"id\\\":)\\d+` to its JSON string to extract the `id` value for validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method=PUT}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in element text",
						"XPath evaluation error"
					],
					"expected_result": "The text content of the `<Status>` element is returned.",
					"notes": "Locates `<Status>` via XPath and returns its inner text. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_text_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element Text via XPath",
				"",
				"This example retrieves the text content of the `<Status>` element from an XML response using XPath locator `//Status` with `onElement: //Status`, enabling evaluation of status values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method=PUT}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in element text"
					],
					"expected_result": "The inner content of the `<Status>` element is extracted.",
					"notes": "Applies a regular expression to the `<Status>` element text to extract core content without tags. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_content_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Content via Regex",
				"",
				"This example selects the `<Status>` element using XPath locator `//Status` with `onElement: //Status` and applies the regular expression `(?<=<Status>).*?(?=</Status>)` to capture its inner content without tags for performance."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method=PUT}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in attribute value",
						"XPath evaluation error"
					],
					"expected_result": "The `status` attribute value is extracted from the `<Response>` element.",
					"notes": "Extracts the `status` attribute from `<Response>` elements using XPath. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_response_status_attribute_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Response Status Attribute via XPath",
				"",
				"This example retrieves the `status` attribute from each `<Response>` element in an XML response using XPath locator `//Response` with `onElement: //Response` and `onAttribute: status`, enabling conditional logic based on attribute values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method=PUT}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in attribute value"
					],
					"expected_result": "The `status` attribute value is validated against `success|failure`.",
					"notes": "Applies a regular expression to the `status` attribute of `<Response>` elements to validate outcome. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_response_status_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Response Status via Regex",
				"",
				"This example locates the `status` attribute on `<Response>` elements using XPath locator `//Response` with `onElement: //Response` and `onAttribute: status`, then applies the regular expression `success|failure` to validate outcome values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method=PUT}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|failure"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"Network timeout",
						"Response too large",
						"Unexpected status code",
						"Unexpected whitespace in response"
					],
					"expected_result": "The full response body of the HTTP PUT request is returned.",
					"notes": "Returns the complete response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "return_put_full_response",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item Full Response",
				"",
				"This example returns the complete response body of an HTTP PUT request to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, and `--Header:Authorization=Basic username:password` with `onElement: responseBody`, allowing downstream steps to process raw data."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in response"
					],
					"expected_result": "The `message` field is extracted from the response body.",
					"notes": "Applies a regular expression to the full response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_message_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Message via Regex",
				"",
				"This example applies the regular expression `(?<=\\\"message\\\":\\\")[^\\\"]+` to the full response body using `onElement: responseBody` to extract the `message` field reliably without parsing the entire JSON."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"message\\\":\\\")[^\\\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"JSONPath evaluation error",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The `updatedItem` object is returned from the JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "select_updated_item_via_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Select Updated Item via JSONPath",
				"",
				"This example locates the `updatedItem` object in the JSON response using JSONPath locator `$.updatedItem` with `onElement: $.updatedItem`, enabling direct access to the updated data for further processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"JSONPath evaluation error",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The `id` value is extracted from the `updatedItem` object.",
					"notes": "Selects `updatedItem` via JSONPath and applies a regular expression to its JSON string. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_updated_item_id_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Updated Item ID via Regex",
				"",
				"This example selects `updatedItem` using JSONPath locator `$.updatedItem` with `onElement: $.updatedItem` and applies the regular expression `(?<=\\\"id\\\":)\\d+` to its JSON string to extract the `id` value for validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in element text",
						"XPath evaluation error"
					],
					"expected_result": "The text content of the `<Status>` element is returned.",
					"notes": "Locates `<Status>` via XPath and returns its inner text. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_text_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element Text via XPath",
				"",
				"This example retrieves the text content of the `<Status>` element from an XML response using XPath locator `//Status` with `onElement: //Status`, enabling evaluation of status values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in element text"
					],
					"expected_result": "The inner content of the `<Status>` element is extracted.",
					"notes": "Applies a regular expression to the `<Status>` element text to extract core content without tags. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_content_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Content via Regex",
				"",
				"This example selects the `<Status>` element using XPath locator `//Status` with `onElement: //Status` and applies the regular expression `(?<=<Status>).*?(?=</Status>)` to capture its inner content without tags for performance."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in attribute value",
						"XPath evaluation error"
					],
					"expected_result": "The `status` attribute value is extracted from the `<Response>` element.",
					"notes": "Extracts the `status` attribute from `<Response>` elements using XPath. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_response_status_attribute_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Response Status Attribute via XPath",
				"",
				"This example retrieves the `status` attribute from each `<Response>` element in an XML response using XPath locator `//Response` with `onElement: //Response` and `onAttribute: status`, enabling conditional logic based on attribute values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method=PUT}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in attribute value"
					],
					"expected_result": "The `status` attribute value is validated against `success|failure`.",
					"notes": "Applies a regular expression to the `status` attribute of `<Response>` elements to validate outcome. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_response_status_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Response Status via Regex",
				"",
				"This example locates the `status` attribute on `<Response>` elements using XPath locator `//Response` with `onElement: //Response` and `onAttribute: status`, then applies the regular expression `success|failure` to validate outcome values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Method=PUT}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|failure"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"Network timeout",
						"Response too large",
						"Unexpected status code",
						"Unexpected whitespace in response"
					],
					"expected_result": "The full response body of the HTTP PUT request is returned.",
					"notes": "Returns the complete response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "return_put_full_response",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item Full Response",
				"",
				"This example returns the complete response body of an HTTP PUT request to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, `--Header:Authorization=Basic username:password`, and `--Header:UserAgent=MyCustomUserAgent`, with `onElement: responseBody` so downstream steps can process the raw data."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in response"
					],
					"expected_result": "The `message` field is extracted from the response body.",
					"notes": "Applies a regular expression to the full response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_message_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Message via Regex",
				"",
				"This example applies the regular expression `(?<=\\\"message\\\":\\\")[^\\\"]+` to the full response body with `onElement: responseBody` to extract the `message` field reliably."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"message\\\":\\\")[^\\\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"JSONPath evaluation error",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The `updatedItem` object is returned from the JSON response.",
					"notes": "Selects the `updatedItem` object using JSONPath. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "select_updated_item_via_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Select Updated Item via JSONPath",
				"",
				"This example locates the `updatedItem` object in the JSON response using JSONPath locator `$.updatedItem` with `onElement: $.updatedItem` to enable direct access to the updated data."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid JSON format",
						"JSONPath evaluation error",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The `id` value is extracted from the `updatedItem` object.",
					"notes": "Selects `updatedItem` via JSONPath and applies a regular expression to its JSON string. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_updated_item_id_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Updated Item ID via Regex",
				"",
				"This example locates the `updatedItem` object using JSONPath locator `$.updatedItem` with `onElement: $.updatedItem` and applies the regular expression `(?<=\\\"id\\\":)\\d+` to extract the numeric `id` value."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in element text",
						"XPath evaluation error"
					],
					"expected_result": "The text content of the `<Status>` element is returned.",
					"notes": "Locates `<Status>` via XPath locator `//Status` and returns its inner text. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_text_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element Text via XPath",
				"",
				"This example retrieves the text content of the `<Status>` element from an XML response using XPath locator `//Status` with `onElement: //Status` to evaluate status values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in element text",
						"XPath evaluation error"
					],
					"expected_result": "The inner content of the `<Status>` element is extracted.",
					"notes": "Applies a regular expression to the `<Status>` element text to extract core content without tags. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_content_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Content via Regex",
				"",
				"This example locates the `<Status>` element using XPath locator `//Status` with `onElement: //Status` and applies the regular expression `(?<=<Status>).*?(?=</Status>)` to capture inner content without tags for performance."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in attribute value",
						"XPath evaluation error"
					],
					"expected_result": "The `status` attribute value is extracted from the `<Response>` element.",
					"notes": "Extracts the `status` attribute from `<Response>` elements using XPath. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_response_status_attribute_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Response Status Attribute via XPath",
				"",
				"This example retrieves the `status` attribute from each `<Response>` element in an XML response using XPath locator `//Response` with `onElement: //Response` and `onAttribute: status` for conditional logic."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in attribute value",
						"XPath evaluation error"
					],
					"expected_result": "The `status` attribute value is validated against `success|failure`.",
					"notes": "Applies a regular expression to the `status` attribute of `<Response>` elements to validate outcome. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_response_status_via_regex",
					"version": "1.0"
				},
				"labels": [
					"HttpRequest",
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Response Status via Regex",
				"",
				"This example locates the `status` attribute on `<Response>` elements using XPath locator `//Response` with `onElement: //Response` and `onAttribute: status`, then applies the regular expression `success|failure` to validate outcome values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|failure"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed response body",
						"Network timeout",
						"Response too large",
						"Unexpected status code",
						"Unexpected whitespace in response"
					],
					"expected_result": "The full response body of the HTTP PUT request is returned.",
					"notes": "Returns the complete response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "return_put_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item with Plain-Text Payload",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99`, `--Header:Authorization=Basic username:password`, and `--Header:UserAgent=MyCustomUserAgent`, then returns the complete response body with `onElement: responseBody` for downstream processing to ensure raw text parsing works even when the service returns non-JSON data."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed response body",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in response"
					],
					"expected_result": "The numeric status code is extracted from the response body.",
					"notes": "Applies a regular expression to the full response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_code_via_regex",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code via Regex",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99`, `--Header:Authorization=Basic username:password`, and `--Header:UserAgent=MyCustomUserAgent`, then applies the regular expression `(?<=Status: )\\d{3}` to the full response body with `onElement: responseBody` to extract the numeric status code, using regex to avoid full payload parsing and focus only on the status line."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"JSONPath evaluation error",
						"Malformed JSON body",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The `updatedItem` object is returned from the response.",
					"notes": "Selects the `updatedItem` object using JSONPath locator `$.updatedItem`. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "select_updated_item_plaintext_via_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Select Updated Item via JSONPath",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization=Basic username:password`, and `--Header:UserAgent=MyCustomUserAgent`, then locates the `updatedItem` object via JSONPath locator `$.updatedItem` with `onElement: $.updatedItem`, using JSONPath to directly target the relevant node without manual string manipulation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"JSONPath evaluation error",
						"Malformed JSON body",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The numeric `id` value is extracted from the `updatedItem` object.",
					"notes": "Selects `updatedItem` via JSONPath and applies a regular expression to its JSON string to extract the numeric `id` value. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_updated_item_id_plaintext_via_regex",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Updated Item ID via Regex",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization=Basic username:password`, and `--Header:UserAgent=MyCustomUserAgent`, then applies the regular expression `(?<=\\\"id\\\":)\\d+` to the `updatedItem` object via `onElement: $.updatedItem` to extract its numeric `id` value, avoiding full JSON parsing and focusing on the identifier."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in element text",
						"XPath evaluation error"
					],
					"expected_result": "The text content of the `<Status>` element is returned.",
					"notes": "Locates `<Status>` via XPath locator `//Status` and returns its inner text. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_text_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element Text via XPath",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization=Basic username:password`, and `--Header:UserAgent=MyCustomUserAgent`, then retrieves the text content of the `<Status>` element via XPath locator `//Status` with `onElement: //Status`, using XPath to directly target the relevant element for validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in element text",
						"XPath evaluation error"
					],
					"expected_result": "The inner content of the `<Status>` element is extracted.",
					"notes": "Applies a regular expression to the `<Status>` element text to extract core content without tags. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_content_via_regex",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Content via Regex",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization=Basic username:password`, and `--Header:UserAgent=MyCustomUserAgent`, then applies the regular expression `(?<=<Status>).*?(?=</Status>)` to the `<Status>` element via `onElement: //Status` to capture its inner content without tags, avoiding capturing surrounding tags and improving performance by focusing on core content."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in attribute value",
						"XPath evaluation error"
					],
					"expected_result": "The `status` attribute value is extracted from the `<Response>` element.",
					"notes": "Extracts the `status` attribute from `<Response>` elements using XPath. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_response_status_attribute_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Response Status Attribute via XPath",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization=Basic username:password`, and `--Header:UserAgent=MyCustomUserAgent`, then retrieves the `status` attribute from the `<Response>` element via XPath locator `//Response` with `onElement: //Response` and `onAttribute: status`, using XPath to extract the attribute directly for conditional logic."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in attribute value",
						"XPath evaluation error"
					],
					"expected_result": "The `status` attribute value is validated against `success|error`.",
					"notes": "Applies a regular expression to the `status` attribute of `<Response>` elements to validate outcome. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_response_status_via_regex",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Response Status via Regex",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization=Basic username:password`, and `--Header:UserAgent=MyCustomUserAgent`, then applies the regular expression `success|error` to the `status` attribute of the `<Response>` element via `onElement: //Response` and `onAttribute: status` to validate outcome values without manual parsing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method=PUT}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed response body",
						"Network timeout",
						"Response too large",
						"Unexpected status code",
						"Unexpected whitespace in response"
					],
					"expected_result": "The full response body of the HTTP PUT request is returned.",
					"notes": "Returns the complete response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "return_put_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item with Plain-Text Payload",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99`, and `--Header:Authorization=Basic username:password`, then returns the complete response body with `onElement: responseBody` for downstream processing to ensure raw text parsing works even when the service returns non-JSON data."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Malformed response body",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in response"
					],
					"expected_result": "The numeric status code is extracted from the response body.",
					"notes": "Applies a regular expression to the full response body. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_code_plaintext_via_regex",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code via Regex",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99`, and `--Header:Authorization=Basic username:password`, then applies the regular expression `(?<=Status: )\\d{3}` to the full response body with `onElement: responseBody` to extract the numeric status code, using regex to avoid full payload parsing and focus only on the status line."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "responseBody",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"JSONPath evaluation error",
						"Malformed JSON body",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The `updatedItem` object is returned from the response.",
					"notes": "Selects the `updatedItem` object using JSONPath locator `$.updatedItem`. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "select_updated_item_plaintext_via_jsonpath",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Select Updated Item via JSONPath",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, and `--Header:Authorization=Basic username:password`, then locates the `updatedItem` object via JSONPath locator `$.updatedItem` with `onElement: $.updatedItem`, using JSONPath to directly target the relevant node without manual string manipulation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"JSONPath evaluation error",
						"Malformed JSON body",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in JSON value"
					],
					"expected_result": "The numeric `id` value is extracted from the `updatedItem` object.",
					"notes": "Selects `updatedItem` via JSONPath and applies a regular expression to its JSON string to extract the numeric `id` value. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_updated_item_id_plaintext_via_regex",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Updated Item ID via Regex",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, and `--Header:Authorization=Basic username:password`, then applies the regular expression `(?<=\\\"id\\\":)\\d+` to the `updatedItem` object via `onElement: $.updatedItem` to extract its numeric `id` value, avoiding full JSON parsing and focusing on the identifier."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in element text",
						"XPath evaluation error"
					],
					"expected_result": "The text content of the `<Status>` element is returned.",
					"notes": "Locates `<Status>` via XPath locator `//Status` and returns its inner text. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_text_plaintext_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element Text via XPath",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, and `--Header:Authorization=Basic username:password`, then retrieves the text content of the `<Status>` element via XPath locator `//Status` with `onElement: //Status`, using XPath to directly target the relevant element for validation."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in element text",
						"XPath evaluation error"
					],
					"expected_result": "The inner content of the `<Status>` element is extracted.",
					"notes": "Applies a regular expression to the `<Status>` element text to extract core content without tags. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_status_content_plaintext_via_regex",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Content via Regex",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, and `--Header:Authorization=Basic username:password`, then applies the regular expression `(?<=<Status>).*?(?=</Status>)` to the `<Status>` element via `onElement: //Status` to capture its inner content without tags, avoiding capturing surrounding tags and improving performance by focusing on core content."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method=PUT}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Response too large",
						"Unexpected whitespace in attribute value",
						"XPath evaluation error"
					],
					"expected_result": "The `status` attribute value is extracted from the `<Response>` element.",
					"notes": "Extracts the `status` attribute from `<Response>` elements using XPath. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_response_status_attribute_plaintext_via_xpath",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Response Status Attribute via XPath",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, and `--Header:Authorization=Basic username:password`, then retrieves the `status` attribute from the `<Response>` element via XPath locator `//Response` with `onElement: //Response` and `onAttribute: status`, using XPath to extract the attribute directly for conditional logic."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method=PUT}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Invalid XML format",
						"Network timeout",
						"Regex match occurs when it shouldn't",
						"Response too large",
						"Unexpected whitespace in attribute value",
						"XPath evaluation error"
					],
					"expected_result": "The `status` attribute value is validated against `success|error`.",
					"notes": "Applies a regular expression to the `status` attribute of `<Response>` elements to validate outcome. All extracted values are converted to a string before regex validation to ensure pattern matching operates on string data.",
					"test_case": "extract_response_status_plaintext_via_regex",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Extract Response Status via Regex",
				"",
				"This example sends an HTTP PUT to `https://api.example.com/v1/items/567` using `--Method=PUT`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, and `--Header:Authorization=Basic username:password`, then applies the regular expression `success|error` to the `status` attribute of the `<Response>` element via `onElement: //Response` and `onAttribute: status` to validate outcome values without manual parsing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Method=PUT}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PUT request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"Validation"
				]
			},
			"description": [
				"### Update Item – Full Response Retrieval",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with a plain-text body and capture the full response body.",
				"It configures the request using `--Method:Put`, `--ContentType:text/plain`, and custom headers, then returns the raw response body unchanged.",
				"Values are converted to strings to ensure consistent processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Put}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body."
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_plaintext_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with a plain-text body and extract the three-digit status code from the response body.",
				"It applies a regular expression `(?<=Status: )\\d{3}` to the response body to capture the status code.",
				"Values are converted to strings so downstream steps handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Put}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body."
					],
					"expected_result": "The value of `updatedItem` from the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with a plain-text body and extract the value of `updatedItem` from the JSON response.",
				"It uses a JSONPath expression `$.updatedItem` to select the updatedItem node.",
				"Values are converted to strings for reliable processing across different data types."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body."
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract id with Regex from JSONPath",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with a plain-text body and extract the numeric `id` value from the `updatedItem` node in the JSON response.",
				"It uses a JSONPath expression `$.updatedItem` to select the node and applies a regular expression `(?<=\\\"id\\\":)\\d+` to extract the numeric ID.",
				"Values are converted to strings so that logging and validation remain consistent."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The text content of the `Status` XML element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element via XPath",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with a plain-text body and extract the text content of the `Status` element from the XML response.",
				"It applies an XPath expression `//Status` to select the element.",
				"It converts values to strings so downstream processes handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The content of the `Status` XML element matching the pattern is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Text with Regex via XPath",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with a plain-text body and validate the content of the `Status` element from the XML response using a regular expression.",
				"It applies an XPath expression `//Status` to select the element and then applies a regular expression `(?<=<Status>)(success|error)(?=</Status>)` to extract only `success` or `error`.",
				"It converts values to strings so downstream processes handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>)(success|error)(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `Response` XML element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Attribute via XPath",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with a plain-text body and extract the `status` attribute value of the `Response` element from the XML response.",
				"It applies an XPath expression `//Response` to select the element and retrieves the `status` attribute value.",
				"It converts values to strings so downstream processes handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `Response` XML element matching the pattern is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Attribute with Regex via XPath",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with a plain-text body and validate the `status` attribute value of the `Response` element from the XML response using a regular expression.",
				"It applies an XPath expression `//Response` to select the element and retrieves the `status` attribute value, then applies a regular expression `success|error` to validate and extract the status.",
				"It converts values to strings so downstream processes handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PUT request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"Validation"
				]
			},
			"description": [
				"### Update Item – Full Response Retrieval with ASCII Encoding",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with an ASCII-encoded, plain-text body and capture the full response body.",
				"It configures the request using `--Method:Put`, `--ContentType:text/plain`, and `--Encoding:ASCII`, then returns the raw response body unchanged.",
				"Values are converted to strings to ensure consistent processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Encoding:ASCII --Method:Put}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_plaintext_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex and ASCII Encoding",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with an ASCII-encoded, plain-text body and extract the three-digit status code from the response body.",
				"It applies a regular expression `(?<=Status: )\\d{3}` to the response body to capture the status code.",
				"Values are converted to strings so downstream steps handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Encoding:ASCII --Method:Put}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The value of `updatedItem` from the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath with ASCII Encoding",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with an ASCII-encoded, plain-text body and extract the value of `updatedItem` from the JSON response.",
				"It uses a JSONPath expression `$.updatedItem` to select the updatedItem node.",
				"Values are converted to strings for reliable processing across data types."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract id with Regex from JSONPath with ASCII Encoding",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with an ASCII-encoded, plain-text body and extract the numeric `id` value from the `updatedItem` node in the JSON response.",
				"It uses a JSONPath expression `$.updatedItem` to select the node and applies a regular expression `(?<=\\\"id\\\":)\\d+` to extract the numeric ID.",
				"Values are converted to strings so logging and validation remain consistent."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The text content of the `Status` XML element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with an ASCII-encoded, plain-text body and extract the text content of the `Status` element from the XML response.",
				"It applies an XPath expression `//Status` to select the element.",
				"It converts values to strings so downstream processes handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The content of the `Status` XML element matching the pattern is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Text with Regex via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with an ASCII-encoded, plain-text body and validate the content of the `Status` element from the XML response using a regular expression.",
				"It applies an XPath expression `//Status` to select the element and then applies a regular expression `(?<=<Status>)(success|error)(?=</Status>)` to extract only `success` or `error`.",
				"It converts values to strings so downstream processes handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>)(success|error)(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `Response` XML element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Attribute via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with an ASCII-encoded, plain-text body and extract the `status` attribute value of the `Response` element from the XML response.",
				"It applies an XPath expression `//Response` to select the element and retrieves the `status` attribute value.",
				"It converts values to strings so downstream processes handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `Response` XML element matching the pattern is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Attribute with Regex via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to update an item by sending an HTTP PUT request with an ASCII-encoded, plain-text body and validate the `status` attribute value of the `Response` element from the XML response using a regular expression.",
				"It applies an XPath expression `//Response` to select the element and retrieves the `status` attribute value, then applies a regular expression `success|error` to validate and extract the status.",
				"It converts values to strings so downstream processes handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PUT request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"Validation"
				]
			},
			"description": [
				"### Update Item – Plain-Text PUT with ASCII Encoding",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PUT request with an ASCII-encoded, plain-text body.",
				"It uses `--Method:Put`, `--ContentType:text/plain`, `--Encoding:ASCII`, and authorization headers, then returns the full response body unchanged.",
				"A regular expression is not applied in this example; all values are simply converted to strings for consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Put}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_plaintext_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex and ASCII Encoding",
				"",
				"This example demonstrates how to extract the three-digit HTTP status code from a plain-text response line after sending an ASCII-encoded PUT request.",
				"A regular expression `(?<=Status: )\\d{3}` is applied to the response body; the assertion passes only if the extracted string matches this three-digit pattern."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Put}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath with ASCII Encoding",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an ASCII-encoded PUT request.",
				"It uses a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings so downstream processes handle JSON data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract id with Regex from JSONPath with ASCII Encoding",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an ASCII-encoded PUT request.",
				"It uses a JSONPath expression `$.updatedItem` and applies a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID.",
				"A regular expression `(?<=\\\"id\\\":)\\d+` is applied to the JSON text; the assertion passes only if the extracted string matches this numeric pattern."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The text content of the `<Status>` XML element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to select the `<Status>` element from an XML response after sending an ASCII-encoded PUT request.",
				"It applies an XPath expression `//Status` and retrieves the element's text content.",
				"Values are converted to strings so downstream processes handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Text with Regex via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element in an XML response after sending an ASCII-encoded PUT request.",
				"It applies an XPath expression `//Status` and then a regular expression `(?<=<Status>)(success|error)(?=</Status>)` to capture the content.",
				"A regular expression `(?<=<Status>)(success|error)(?=</Status>)` is applied to the element's visible text; the assertion passes only if it matches one of the allowed values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>)(success|error)(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract status Attribute via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to retrieve the `status` attribute from the `<Response>` element in an XML response after sending an ASCII-encoded PUT request.",
				"It applies an XPath expression `//Response` and reads the `status` attribute value.",
				"Values are converted to strings so downstream processes handle data uniformly."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate status Attribute with Regex via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response matches either `success` or `error` after sending an ASCII-encoded PUT request.",
				"It applies an XPath expression `//Response` and then a regular expression `success|error` to assert the attribute value.",
				"A regular expression `success|error` is applied to the attribute; the assertion passes only if it matches one of the allowed values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization=Basic username:password --Encoding:ASCII --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PUT request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"Validation"
				]
			},
			"description": [
				"### Update Item – Plain-Text PUT with ASCII Encoding and Custom Headers",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PUT request with an ASCII-encoded, plain-text body and custom authorization and user-agent headers.",
				"It uses `--Method:Put`, `--ContentType:text/plain`, `--Encoding:ASCII`, `--Header:Authorization:Basic username:password`, and `--Header:UserAgent:MyCustomUserAgent`, then returns the full response body unchanged.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_plaintext_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex and ASCII Encoding",
				"",
				"This example demonstrates how to extract the three-digit HTTP status code from a plain-text response line after sending an ASCII-encoded PUT request.",
				"A regular expression `(?<=Status: )\\d{3}` is applied to the response body; the assertion passes only if the extracted string matches this three-digit pattern."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath with ASCII Encoding",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an ASCII-encoded PUT request.",
				"It uses a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract id with Regex from JSONPath with ASCII Encoding",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an ASCII-encoded PUT request.",
				"It uses a JSONPath expression `$.updatedItem` and applies a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID.",
				"A regular expression `(?<=\\\"id\\\":)\\d+` is applied to the JSON text; the assertion passes only if the extracted string matches this numeric pattern."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The text content of the `<Status>` XML element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to select the `<Status>` element from an XML response after sending an ASCII-encoded PUT request.",
				"It applies an XPath expression `//Status` and retrieves the element's text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Text with Regex via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element in an XML response after sending an ASCII-encoded PUT request.",
				"It applies an XPath expression `//Status` and then a regular expression `(?<=<Status>)(success|error)(?=</Status>)` to capture the content.",
				"A regular expression `(?<=<Status>)(success|error)(?=</Status>)` is applied to the element's visible text; the assertion passes only if it matches one of the allowed values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>)(success|error)(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract status Attribute via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to retrieve the `status` attribute from the `<Response>` element in an XML response after sending an ASCII-encoded PUT request.",
				"It applies an XPath expression `//Response` and reads the `status` attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate status Attribute with Regex via XPath with ASCII Encoding",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response matches either `success` or `error` after sending an ASCII-encoded PUT request.",
				"It applies an XPath expression `//Response` and then a regular expression `success|error` to assert the attribute value.",
				"A regular expression `success|error` is applied to the attribute; the assertion passes only if it matches one of the allowed values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed response body",
						"missing Status line",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PUT request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_form_urlencoded_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item – Form-Encoded PUT with ASCII Encoding and Custom Headers",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PUT request with an ASCII-encoded, x-www-form-urlencoded body and custom authorization and user-agent headers.",
				"It uses `--Method:Put`, `--ContentType:x-www-form-urlencoded`, `--Field:Name=PremiumWidget`, `--Field:Price=99.99`, `--Encoding:ASCII`, `--Header:Authorization:Basic username:password`, and `--Header:UserAgent:MyCustomUserAgent`, then returns the full response body unchanged.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed response body",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_form_urlencoded_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex and ASCII Encoding for Form-Encoded Request",
				"",
				"This example demonstrates how to extract the three-digit HTTP status code from a plain-text response line after sending an ASCII-encoded, x-www-form-urlencoded PUT request.",
				"A regular expression `(?<=Status: )\\d{3}` is applied to the response body; the assertion passes only if the extracted string matches this three-digit pattern."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed response body",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_form_urlencoded_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath with Form-Encoded PUT and ASCII Encoding",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an ASCII-encoded, x-www-form-urlencoded PUT request.",
				"It uses a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed response body",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_form_urlencoded_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract id with Regex from JSONPath with Form-Encoded PUT and ASCII Encoding",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an ASCII-encoded, x-www-form-urlencoded PUT request.",
				"It uses a JSONPath expression `$.updatedItem` and applies a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID; the assertion passes only if the extracted string matches this numeric pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The text content of the `<Status>` XML element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_form_urlencoded_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element via XPath with Form-Encoded PUT and ASCII Encoding",
				"",
				"This example demonstrates how to select the `<Status>` element from an XML response after sending an ASCII-encoded, x-www-form-urlencoded PUT request.",
				"It applies an XPath expression `//Status` to retrieve the element's text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element matching the pattern is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_form_urlencoded_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Text with Regex via XPath with Form-Encoded PUT and ASCII Encoding",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element in an XML response after sending an ASCII-encoded, x-www-form-urlencoded PUT request.",
				"It applies an XPath expression `//Status` and then applies a regular expression `(?<=<Status>)(success|error)(?=</Status>)` to capture the content.",
				"A regular expression `(?<=<Status>)(success|error)(?=</Status>)` is applied to the element's visible text; the assertion passes only if it matches one of the allowed values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>)(success|error)(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_form_urlencoded_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract status Attribute via XPath with Form-Encoded PUT and ASCII Encoding",
				"",
				"This example demonstrates how to retrieve the `status` attribute from the `<Response>` element in an XML response after sending an ASCII-encoded, x-www-form-urlencoded PUT request.",
				"It applies an XPath expression `//Response` and reads the `status` attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_form_urlencoded_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate status Attribute with Regex via XPath with Form-Encoded PUT and ASCII Encoding",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response matches either `success` or `error` after sending an ASCII-encoded, x-www-form-urlencoded PUT request.",
				"It applies an XPath expression `//Response` and then applies a regular expression `success|error` to assert the attribute value.",
				"A regular expression `success|error` is applied to the attribute; the assertion passes only if it matches one of the allowed values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed response body",
						"missing Status line",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PUT request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xml_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item – XML Body PUT with ASCII Encoding and Custom Headers",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PUT request with an ASCII-encoded XML body and custom authorization and user-agent headers.",
				"It uses `--Method:Put`, `--ContentType:text/xml`, `--Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item>`, `--Encoding:ASCII`, `--Header:Authorization:Basic username:password`, and `--Header:UserAgent:MyCustomUserAgent`, then returns the full response body unchanged.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed response body",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xml_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex and ASCII Encoding for XML Request",
				"",
				"This example demonstrates how to extract the three-digit HTTP status code from a plain-text response line after sending an ASCII-encoded PUT request with an XML body.",
				"A regular expression `(?<=Status: )\\d{3}` is applied to the response body; the assertion passes only if the extracted string matches this three-digit pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xml_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath with XML Request and ASCII Encoding",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an ASCII-encoded PUT request with an XML body.",
				"It uses a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xml_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract id with Regex from JSONPath with XML Request and ASCII Encoding",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an ASCII-encoded PUT request with an XML body.",
				"It uses a JSONPath expression `$.updatedItem` and applies a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID; the assertion passes only if the extracted string matches this numeric pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The text content of the `<Status>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Element via XPath with XML Body PUT and ASCII Encoding",
				"",
				"This example demonstrates how to select the `<Status>` element from an XML response after sending an ASCII-encoded PUT request with an XML body.",
				"It applies an XPath expression `//Status` to retrieve the element's text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element matching the pattern is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Text with Regex via XPath with XML Body PUT and ASCII Encoding",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element in an XML response after sending an ASCII-encoded PUT request with an XML body.",
				"It applies an XPath expression `//Status` and then applies a regular expression `(?<=<Status>).*?(?=</Status>)` to capture the content.",
				"A regular expression `(?<=<Status>).*?(?=</Status>)` is applied to the element's visible text; the assertion passes only if it matches one of the allowed values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract status Attribute via XPath with XML Body PUT and ASCII Encoding",
				"",
				"This example demonstrates how to retrieve the `status` attribute from the `<Response>` element in an XML response after sending an ASCII-encoded PUT request with an XML body.",
				"It applies an XPath expression `//Response` and reads the `status` attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_put_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate status Attribute with Regex via XPath with XML Body PUT and ASCII Encoding",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response matches either `success` or `error` after sending an ASCII-encoded PUT request with an XML body.",
				"It applies an XPath expression `//Response` and then applies a regular expression `success|error` to assert the attribute value.",
				"A regular expression `success|error` is applied to the attribute; the assertion passes only if it matches one of the allowed values."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Put}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		// PATCH
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PATCH request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_json_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item – JSON Body PATCH",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PATCH request with a JSON body.",
				"It uses `--Method:Patch`, `--ContentType:application/json`, and `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, then returns the full response body unchanged.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `message` field is extracted from the JSON response and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_json_message_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Message with Regex",
				"",
				"This example demonstrates how to extract the `message` field from a JSON response after sending an HTTP PATCH request with a JSON body.",
				"A regular expression `(?<=\\\"message\\\":\\\")[^\\\"]+` is applied to the response body; the assertion passes only if the extracted string matches this pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"message\\\":\\\")[^\\\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an HTTP PATCH request with a JSON body.",
				"It uses a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract id with Regex from JSONPath",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an HTTP PATCH request with a JSON body.",
				"It uses a JSONPath expression `$.updatedItem` and applies a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID; the assertion passes only if the extracted string matches this numeric pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response after sending an HTTP PATCH request with a JSON body.",
				"It uses `--Method:Patch`, `--ContentType:application/json`, and `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, then applies an XPath expression `//Status` to extract the element's text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element matching the allowed values is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element in an XML response after sending an HTTP PATCH request with a JSON body.",
				"It applies an XPath expression `//Status` and then applies a regular expression `(?<=<Status>).*?(?=</Status>)` to extract the content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract `status` Attribute via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the `status` attribute value from the `<Response>` element in an XML response after sending an HTTP PATCH request with a JSON body.",
				"It uses `--Method:Patch`, `--ContentType:application/json`, and `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, then applies an XPath expression `//Response` to retrieve the `status` attribute.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate `status` Attribute with Regex via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response matches either `success` or `failure` after sending an HTTP PATCH request with a JSON body.",
				"It applies an XPath expression `//Response` and then applies a regular expression `success|failure` to assert the attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|failure"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response after sending an HTTP PATCH request with a JSON body.",
				"It uses `--Method:Patch`, `--ContentType:application/json`, and `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, then applies an XPath expression `//Status` to extract the element's text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element matching the allowed values is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element in an XML response after sending an HTTP PATCH request with a JSON body.",
				"It applies an XPath expression `//Status` and then a regular expression `(?<=<Status>).*?(?=</Status>)` to extract the content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract `status` Attribute via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the `status` attribute value from the `<Response>` element in an XML response after sending an HTTP PATCH request with a JSON body.",
				"It uses `--Method:Patch`, `--ContentType:application/json`, and `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, then applies an XPath expression `//Response` to retrieve the `status` attribute.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate `status` Attribute with Regex via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response matches either `success` or `failure` after sending an HTTP PATCH request with a JSON body.",
				"It applies an XPath expression `//Response` and then a regular expression `success|failure` to assert the attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|failure"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a JSON body.",
				"It uses `--Method:Patch`, `--ContentType:application/json`, `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, `--Header:Authorization:Basic username:password`, and `--Header:Accept:application/xml`, then applies an XPath expression `//Status` to extract the element's text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element from an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a JSON body.",
				"It applies an XPath expression `//Status` and then a regular expression `(?<=<Status>).*?(?=</Status>)` to extract the content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract `status` Attribute via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the `status` attribute value from the `<Response>` element in an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a JSON body.",
				"It applies an XPath expression `//Response` to retrieve the `status` attribute.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate `status` Attribute with Regex via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response (with `Accept: application/xml`) matches either `success` or `failure` after sending an HTTP PATCH request with a JSON body.",
				"It applies an XPath expression `//Response` and then a regular expression `success|failure` to assert the attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|failure"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PATCH request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_json_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item – JSON Body PATCH",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PATCH request with a JSON body.",
				"It uses `--Method:Patch`, `--ContentType:application/json`, `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, `--Header:Authorization:Basic username:password`, and `--Header:UserAgent:MyCustomUserAgent`, then returns the full response body unchanged.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Method:Patch}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `message` field is extracted from the JSON response and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_json_message_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Confirmation Message with Regex",
				"",
				"This example demonstrates how to extract the confirmation `message` field from a JSON response after sending an HTTP PATCH request with a JSON body.",
				"A regular expression `(?<=\\\"message\\\":\\\")[^\\\"]+` is applied to the response body; the assertion passes only if the extracted string matches this pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Method:Patch}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"message\\\":\\\")[^\\\"]+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an HTTP PATCH request with a JSON body.",
				"It uses `--Method:Patch`, `--ContentType:application/json`, `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, `--Header:Authorization:Basic username:password`, and `--Header:UserAgent:MyCustomUserAgent`, then applies a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Item ID with Regex from JSONPath",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an HTTP PATCH request with a JSON body.",
				"It applies a JSONPath expression `$.updatedItem` and then a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID; the assertion passes only if the extracted string matches this numeric pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a JSON body and custom headers.",
				"It uses `--Method:Patch`, `--ContentType:application/json`, `--Body:{\"name\":\"Premium Widget\",\"price\":99.99}`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, and `--Header:Accept:application/xml`, then applies an XPath expression `//Status` to extract the element's text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element matching the allowed values is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element from an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a JSON body and custom headers.",
				"It applies an XPath expression `//Status` and then a regular expression `(?<=<Status>).*?(?=</Status>)` to extract the content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract `status` Attribute via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to extract the `status` attribute value from the `<Response>` element in an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a JSON body and custom headers.",
				"It applies an XPath expression `//Response` to retrieve the `status` attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate `status` Attribute with Regex via XPath from XML Response after JSON-Body PATCH",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response (with `Accept: application/xml`) matches either `success` or `failure` after sending an HTTP PATCH request with a JSON body and custom headers.",
				"It applies an XPath expression `//Response` and then a regular expression `success|failure` to assert the attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:application/json --Body:{\"name\":\"Premium Widget\",\"price\":99.99} --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|failure"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PATCH request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item – Plain-Text PATCH",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PATCH request with a plain-text body.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, and `--Body:Name=PremiumWidget;Price=99.99`, then returns the full response body unchanged.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Method:Patch}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_plaintext_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex via Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the three-digit HTTP status code from a plain-text response line after sending an HTTP PATCH request with a plain-text body.",
				"A regular expression `(?<=Status: )\\d{3}` is applied to the response body; the assertion passes only if the extracted string matches this three-digit pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Method:Patch}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath from Plain-Text PATCH",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an HTTP PATCH request with a plain-text body.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Accept:application/json`, then applies a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract id with Regex from JSONPath via Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an HTTP PATCH request with a plain-text body.",
				"It applies a JSONPath expression `$.updatedItem`, `--Header:Accept:application/json`, and then a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID; the assertion passes only if the extracted string matches this numeric pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a plain-text body.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, and `--Header:Accept:application/xml`, then applies an XPath expression `//Status` to extract the element’s text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element matching the allowed values is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element from an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a plain-text body.",
				"It applies an XPath expression `//Status` and then a regular expression `(?<=<Status>).*?(?=</Status>)` to extract the content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract `status` Attribute via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `status` attribute value from the `<Response>` element in an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a plain-text body.",
				"It applies an XPath expression `//Response` to retrieve the `status` attribute.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate `status` Attribute with Regex via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response (with `Accept: application/xml`) matches either `success` or `error` after sending an HTTP PATCH request with a plain-text body.",
				"It applies an XPath expression `//Response` and then a regular expression `success|error` to assert the attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url=https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PATCH request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item – Plain-Text PATCH",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PATCH request with a plain-text payload and a basic authorization header.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99`, and `--Header:Authorization:Basic username:password`, then returns the full response body unchanged.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization:Basic username:password --Method:Patch}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_plaintext_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex via Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the three-digit HTTP status code from a plain-text response after sending an HTTP PATCH request with a plain-text payload and a basic authorization header.",
				"A regular expression `(?<=Status: )\\d{3}` is applied to the response body; the assertion passes only if the extracted string matches this three-digit pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url=https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization:Basic username:password --Method:Patch}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath from Plain-Text PATCH",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an HTTP PATCH request with a plain-text payload and a basic authorization header.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, and `--Header:Accept:application/json`, then applies a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url=https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Item ID with Regex from JSONPath via Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an HTTP PATCH request with a plain-text payload and a basic authorization header.",
				"It applies a JSONPath expression `$.updatedItem` and then a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID; the assertion passes only if the extracted string matches this numeric pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url=https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a plain-text body.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, and `--Header:Accept:application/xml`, then applies an XPath expression `//Status` to extract the element's text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element from an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a plain-text body.",
				"It applies an XPath expression `//Status` and then a regular expression `(?<=<Status>).*?(?=</Status>)` to extract the content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract `status` Attribute via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `status` attribute value from the `<Response>` element in an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a plain-text body.",
				"It applies an XPath expression `//Response` to retrieve the `status` attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:Accept:application/xml --Method:Patch}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate `status` Attribute with Regex via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response (with `Accept: application/xml`) matches either `success` or `error` after sending an HTTP PATCH request with a plain-text body.",
				"It applies an XPath expression `//Response` and then a regular expression `success|error` to assert the attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:Accept:application/xml --Method:Patch}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PATCH request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item – Plain-Text PATCH with Custom Headers",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PATCH request with a plain-text payload and the headers `Authorization:Basic username:password` and `UserAgent:MyCustomUserAgent`.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99`, `--Header:Authorization:Basic username:password`, and `--Header:UserAgent:MyCustomUserAgent`, then returns the full response body unchanged.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Method:Patch}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_plaintext_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex via Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the three-digit HTTP status code from a plain-text response after sending an HTTP PATCH request with a plain-text body and the headers `Authorization:Basic username:password` and `UserAgent:MyCustomUserAgent`.",
				"A regular expression `(?<=Status: )\\d{3}` is applied to the response body; the assertion passes only if the extracted string matches this three-digit pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Method:Patch}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath from Plain-Text PATCH",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an HTTP PATCH request with a plain-text payload and the headers `Authorization:Basic username:password`, `UserAgent:MyCustomUserAgent`, and `Accept:application/json`.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, and `--Header:Accept:application/json`, then applies a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Item ID with Regex from JSONPath via Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an HTTP PATCH request with a plain-text payload and the headers `Authorization:Basic username:password`, `UserAgent:MyCustomUserAgent`, and `Accept:application/json`.",
				"It applies a JSONPath expression `$.updatedItem`, `--Header:Accept:application/json`, and then a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID; the assertion passes only if the extracted string matches this numeric pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a plain-text payload and the headers `Authorization:Basic username:password` and `UserAgent:MyCustomUserAgent`.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, and `--Header:Accept:application/xml`, then applies an XPath expression `//Status` to extract the element's text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element from an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a plain-text payload and the headers `Authorization:Basic username:password` and `UserAgent:MyCustomUserAgent`.",
				"It applies an XPath expression `//Status` and a regex `(?<=<Status>).*?(?=</Status>)` to extract the element’s inner content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract `status` Attribute via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `status` attribute value from the `<Response>` element in an XML response (with `Accept: application/xml`) after sending an HTTP PATCH request with a plain-text payload and the headers `Authorization:Basic username:password` and `UserAgent:MyCustomUserAgent`.",
				"It applies an XPath expression `//Response` to retrieve the `status` attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate `status` Attribute with Regex via XPath from XML Response after Plain-Text PATCH",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response (with `Accept: application/xml`) matches either `success` or `error` after sending an HTTP PATCH request with a plain-text payload and the headers `Authorization:Basic username:password` and `UserAgent:MyCustomUserAgent`.",
				"It applies an XPath expression `//Response` and then a regular expression `success|error` to assert the attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PATCH request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item – Plain-Text PATCH with ASCII Encoding",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PATCH request with an ASCII-encoded, plain-text body.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Encoding:ASCII`, and `--Body:Name=PremiumWidget;Price=99.99`, then returns the full response body unchanged.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Encoding:ASCII --Method:Patch}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_plaintext_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex via Plain-Text PATCH with ASCII Encoding",
				"",
				"This example demonstrates how to extract the three-digit HTTP status code from a plain-text response line after sending an HTTP PATCH request with an ASCII-encoded, plain-text body.",
				"A regular expression `(?<=Status: )\\d{3}` is applied to the response body; the assertion passes only if the extracted string matches this three-digit pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Encoding:ASCII --Method:Patch}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath from Plain-Text PATCH with ASCII Encoding",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an HTTP PATCH request with an ASCII-encoded, plain-text body.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Encoding:ASCII`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, and `--Header:Accept:application/json`, then applies a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url=https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract id with Regex from JSONPath via Plain-Text PATCH with ASCII Encoding",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an HTTP PATCH request with an ASCII-encoded, plain-text body.",
				"It applies a JSONPath expression `$.updatedItem`, `--Header:Accept:application/json`, and then a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID; the assertion passes only if the extracted string matches this numeric pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url=https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload and an `Accept: application/xml` header.",
				"It applies an XPath expression `//Status` to extract the element’s text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element from an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload and an `Accept: application/xml` header.",
				"It applies an XPath expression `//Status` and a regex `(?<=<Status>).*?(?=</Status>)` to extract the element’s inner content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract `status` Attribute via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `status` attribute value from the `<Response>` element in an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload and an `Accept: application/xml` header.",
				"It applies an XPath expression `//Response` to retrieve the `status` attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate `status` Attribute with Regex via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response matches either `success` or `error` after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload and an `Accept: application/xml` header.",
				"It applies an XPath expression `//Response` and then a regex `success|error` to assert the attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url=https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The complete HTTP response body from the PATCH request is captured as a string for downstream processing.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_plaintext_full_response",
					"version": "1.0"
				},
				"labels": [
					"ResponseRetrieval",
					"Validation"
				]
			},
			"description": [
				"### Update Item – Plain-Text PATCH with ASCII Encoding",
				"",
				"This example demonstrates how to update an item's name and price by sending an HTTP PATCH request with an ASCII-encoded, plain-text payload.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99`, `--Header:Authorization:Basic username:password`, and `--Encoding:ASCII`, then returns the full response body unchanged.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization:Basic username:password --Encoding:ASCII --Method:Patch}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed plain-text response",
						"missing Status line",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The first three-digit status code is extracted from the response body and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_plaintext_status_code_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Status Code with Regex via Plain-Text PATCH with ASCII Encoding",
				"",
				"This example demonstrates how to extract the three-digit HTTP status code from a plain-text response line after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload and the header `Authorization:Basic username:password`.",
				"A regular expression `(?<=Status: )\\d{3}` is applied to the response body; the assertion passes only if the extracted string matches this three-digit pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99 --Header:Authorization:Basic username:password --Encoding:ASCII --Method:Patch}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath from Plain-Text PATCH with ASCII Encoding",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload and the headers `Authorization:Basic username:password` and `Accept:application/json`.",
				"It uses `--Method:Patch`, `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Encoding:ASCII`, and `--Header:Accept:application/json`, then applies a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Encoding:ASCII --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Item ID with Regex from JSONPath via Plain-Text PATCH with ASCII Encoding",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload and the headers `Authorization:Basic username:password` and `Accept:application/json`.",
				"It applies a JSONPath expression `$.updatedItem`, and then a regular expression `(?<=\\\"id\\\":)\\d+` to capture the ID; the assertion passes only if the extracted string matches this numeric pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Encoding:ASCII --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password` and `Accept:application/xml`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Encoding:ASCII`, `--Header:Accept:application/xml`, and `--Method:Patch`, then applies an XPath expression `//Status` to extract the element’s text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element from an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password` and `Accept:application/xml`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Encoding:ASCII`, `--Header:Accept:application/xml`, and `--Method:Patch`, then applies an XPath expression `//Status` and a regex `(?<=<Status>).*?(?=</Status>)` to extract the element’s inner content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"description": [
				"### Extract `status` Attribute via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `status` attribute value from the `<Response>` element in an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password` and `Accept:application/xml`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Encoding:ASCII`, `--Header:Accept:application/xml`, and `--Method:Patch`, then applies an XPath expression `//Response` to retrieve the attribute.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Validate `status` Attribute with Regex via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response matches either `success` or `error` after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password` and `Accept:application/xml`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Encoding:ASCII`, `--Header:Accept:application/xml`, and `--Method:Patch`, then applies an XPath expression `//Response` and a regex `success|error` to assert the attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password` and `UserAgent:MyCustomUserAgent` and `Accept:application/xml`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, `--Encoding:ASCII`, `--Header:Accept:application/xml`, and `--Method:Patch`, then applies an XPath expression `//Status` to extract the element’s text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element from an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password` and `UserAgent:MyCustomUserAgent` and `Accept:application/xml`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, `--Encoding:ASCII`, `--Header:Accept:application/xml`, and `--Method:Patch`, then applies an XPath expression `//Status` and a regex `(?<=<Status>).*?(?=</Status>)` to extract the element’s inner content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `updatedItem` node",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The `updatedItem` object from the JSON response is selected and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"Validation"
				]
			},
			"description": [
				"### Extract updatedItem via JSONPath from Plain-Text PATCH with ASCII Encoding",
				"",
				"This example demonstrates how to select the `updatedItem` object from a JSON response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password`, `UserAgent:MyCustomUserAgent`, and `Accept:application/json`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, `--Encoding:ASCII`, `--Header:Accept:application/json`, and `--Method:Patch`, then applies a JSONPath expression `$.updatedItem` to retrieve the node.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"5xx server error",
						"malformed JSON response",
						"missing `id` field",
						"missing `updatedItem` node",
						"regex match occurs when it shouldn't",
						"unexpected HTTP 3xx redirect",
						"unexpected whitespace or formatting in the response body"
					],
					"expected_result": "The numeric `id` value under `updatedItem` in the JSON response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_jsonpath_updated_item_id_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"JsonPathExtraction",
					"RegexValidation",
					"Validation"
				]
			},
			"description": [
				"### Extract Item ID with Regex from JSONPath via Plain-Text PATCH with ASCII Encoding",
				"",
				"This example demonstrates how to extract the numeric `id` value from the `updatedItem` object in a JSON response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password`, `UserAgent:MyCustomUserAgent`, and `Accept:application/json`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, `--Encoding:ASCII`, `--Header:Accept:application/json`, and `--Method:Patch`, then applies a JSONPath expression `$.updatedItem` and a regex `(?<=\\\"id\\\":)\\d+` to capture the ID; the assertion passes only if the extracted string matches this numeric pattern.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Header:Accept:application/json --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"description": [
				"### Extract `<Status>` Element Text via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `<Status>` element text from an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password`, `UserAgent:MyCustomUserAgent`, and `Accept:application/xml`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, `--Encoding:ASCII`, `--Header:Accept:application/xml`, and `--Method:Patch`, then applies an XPath expression `//Status` to extract the element’s text content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The `<Status>` element text from the XML response is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"Validation"
				]
			},
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"description": [
				"### Extract `<Status>` Element Inner Text with Regex via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the inner text of the `<Status>` element from an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password`, `UserAgent:MyCustomUserAgent`, and `Accept:application/xml`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, `--Encoding:ASCII`, `--Header:Accept:application/xml`, and `--Method:Patch`, then applies an XPath expression `//Status` and a regex `(?<=<Status>).*?(?=</Status>)` to extract the element’s inner content.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the element text"
					],
					"expected_result": "The inner text of the `<Status>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementText",
					"RegexValidation",
					"Validation"
				]
			},
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"description": [
				"### Extract `status` Attribute via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to extract the `status` attribute value from the `<Response>` element in an XML response after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password`, `UserAgent:MyCustomUserAgent`, and `Accept:application/xml`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, `--Encoding:ASCII`, `--Header:Accept:application/xml`, and `--Method:Patch`, then applies an XPath expression `//Response` to retrieve the `status` attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element is extracted and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"Validation"
				]
			},
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onAttribute": "status",
				"onElement": "//Response",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"description": [
				"### Validate `status` Attribute with Regex via XPath from XML Response after ASCII-Encoded Plain-Text PATCH",
				"",
				"This example demonstrates how to validate that the `status` attribute of the `<Response>` element in an XML response matches either `success` or `error` after sending an HTTP PATCH request with an ASCII-encoded, plain-text payload with the headers `Authorization:Basic username:password`, `UserAgent:MyCustomUserAgent`, and `Accept:application/xml`.",
				"It uses `--ContentType:text/plain`, `--Body:Name=PremiumWidget;Price=99.99;Stock=150`, `--Header:Authorization:Basic username:password`, `--Header:UserAgent:MyCustomUserAgent`, `--Encoding:ASCII`, `--Header:Accept:application/xml`, and `--Method:Patch`, then applies an XPath expression `//Response` and a regex `success|error` to assert the attribute value.",
				"Values are converted to strings to ensure consistent downstream processing."
			],
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Incorrect XPath indexing or attribute usage",
						"Malformed XML response",
						"Regex match occurs when it shouldn't",
						"Unexpected DOM structure",
						"Unexpected whitespace or formatting in the attribute value"
					],
					"expected_result": "The `status` attribute value of the `<Response>` element matching the allowed pattern is validated and returned as a string.",
					"notes": "All returned values are converted to strings so validation and logging remain robust across data types.",
					"test_case": "send_http_request_patch_xml_xpath_response_attribute_status_regex_extraction",
					"version": "1.0"
				},
				"labels": [
					"ElementAttributeCheck",
					"RegexValidation",
					"Validation"
				]
			},
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Url=https://api.example.com/v1/items/567 --ContentType:text/plain --Body:Name=PremiumWidget;Price=99.99;Stock=150 --Header:Authorization:Basic username:password --Header:UserAgent:MyCustomUserAgent --Encoding:ASCII --Header:Accept:application/xml --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"description": [
				"Send a Patch request with a plain-text payload to update the item's name and price."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"description": [
				"Extract the HTTP status code from a plain-text response line like \"Status: 200 OK\"."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"description": [
				"Select the updated item object in the JSON response under the \"updatedItem\" key."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"description": [
				"Extract the numeric item ID from the JSON \"updatedItem.id\" field."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},

		{
			"description": [
				"Select the <Status> element from an XML response after the Patch."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"description": [
				"Extract the text inside the <Status> tag, e.g. \"Success\" or \"Failure\"."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"description": [
				"Get the status attribute from the <Response> element in the XML reply."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"description": [
				"Validate that the status attribute is either \"success\" or \"error\"."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:x-www-form-urlencoded --Field:Name=PremiumWidget --Field:Price=99.99 --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		},

		{
			"description": [
				"Send a Patch request with a plain-text payload to update the item's name and price."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"description": [
				"Extract the HTTP status code from a plain-text response line like \"Status: 200 OK\"."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=Status: )\\d{3}"
			}
		},
		{
			"description": [
				"Select the updated item object in the JSON response under the \"updatedItem\" key."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"description": [
				"Extract the numeric item ID from the JSON \"updatedItem.id\" field."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "$.updatedItem",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=\\\"id\\\":)\\d+"
			}
		},
		{
			"description": [
				"Select the <Status> element from an XML response after the Patch."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"description": [
				"Extract the text inside the <Status> tag, e.g. \"Success\" or \"Failure\"."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "//Status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "(?<=<Status>).*?(?=</Status>)"
			}
		},
		{
			"description": [
				"Get the status attribute from the <Response> element in the XML reply."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest"
			}
		},
		{
			"description": [
				"Validate that the status attribute is either \"success\" or \"error\"."
			],
			"rule": {
				"argument": "{{$ --Url:https://api.example.com/v1/items/567 --ContentType:text/xml --Body:<Item><Name>PremiumWidget</Name><Price>99.99</Price></Item> --Header:Authorization=Basic username:password --Header:UserAgent=MyCustomUserAgent --Encoding:ASCII --Method:Patch}}",
				"onElement": "//Response",
				"onAttribute": "status",
				"pluginName": "SendHttpRequest",
				"regularExpression": "success|error"
			}
		}
	],
	"key": "SendHttpRequest",
	"manifestVersion": 4,
	"outputParameters": [
		{
			"description": [
				"Extracted content from the HTTP response body after applying element, attribute, or pattern rules.",
				"When no extraction rules are set, the full response body is available.",
				"Processed content returned by the HTTP call is available through this parameter."
			],
			"name": "HttpResponse",
			"type": "Any"
		},
		{
			"description": [
				"Headers returned by the HTTP response as name–value pairs.",
				"Metadata such as content type, cache directives, and server information included.",
				"Values available as a key–value map within the workflow."
			],
			"name": "HttpResponseHeaders",
			"type": "Any"
		},
		{
			"description": [
				"Numeric HTTP status code returned by the server.",
				"Common codes include success (200), redirection (3xx), client errors (4xx), and server errors (5xx).",
				"Status code values guide decision flow based on request outcome."
			],
			"name": "HttpStatusCode",
			"type": "Any"
		}
	],
	"parameters": [
		{
			"description": [
				"Data sent in the body of POST or PUT requests to the server.",
				"It carries information like form entries or JSON payloads.",
				"Correct body content ensures the server receives the intended data."
			],
			"name": "Body",
			"type": "String"
		},
		{
			"description": [
				"Defines how the server should interpret the request body format.",
				"Formats include JSON, XML, plain text, or binary data.",
				"Correct content type ensures the server parses the data correctly."
			],
			"name": "ContentType",
			"type": "String",
			"values": [
				{
					"description": [
						"JavaScript Object Notation is a lightweight format for structured data.",
						"It is easy for people to read and machines to parse.",
						"APIs often use JSON for data exchange."
					],
					"name": "application/json"
				},
				{
					"description": [
						"A generic binary format for data without a specific type.",
						"It allows transferring any arbitrary binary content.",
						"Use it when the data format is unknown or varied."
					],
					"name": "application/octet-stream"
				},
				{
					"description": [
						"Portable Document Format preserves document layout and appearance.",
						"It is ideal for forms, manuals, and print-ready documents.",
						"Readers display PDFs consistently across devices."
					],
					"name": "application/pdf"
				},
				{
					"description": [
						"Extensible Markup Language represents structured data with tags.",
						"It works for both human reading and machine processing.",
						"XML is common for web services and configuration files."
					],
					"name": "application/xml"
				},
				{
					"description": [
						"MPEG audio format compresses sound files with good quality.",
						"It is widely used for music and spoken audio online.",
						"MP3 files play on most devices without extra software."
					],
					"name": "audio/mpeg"
				},
				{
					"description": [
						"JPEG image format compresses photos with small file sizes.",
						"It works best for complex images with many colors.",
						"Most web photos use JPEG for balance between quality and size."
					],
					"name": "image/jpeg"
				},
				{
					"description": [
						"PNG image format uses lossless compression for clear graphics.",
						"It supports transparency for layered designs.",
						"Web icons and logos often use PNG for sharp detail."
					],
					"name": "image/png"
				},
				{
					"description": [
						"Multipart form data allows uploading files with form fields.",
						"It bundles text entries and binary files in one request.",
						"Web forms use it to send images, documents, and text together."
					],
					"name": "multipart/form-data"
				},
				{
					"description": [
						"CSS style sheets describe how HTML content looks on a page.",
						"They control layout, colors, fonts, and spacing.",
						"Web pages use CSS to maintain a consistent design."
					],
					"name": "text/css"
				},
				{
					"description": [
						"HTML documents structure web content with tags.",
						"They mark headings, paragraphs, links, and lists.",
						"Browsers render HTML to display web pages."
					],
					"name": "text/html"
				},
				{
					"description": [
						"Plain text format contains unformatted characters only.",
						"It works for simple messages or logs without styling.",
						"Any device or program can read plain text files."
					],
					"name": "text/plain"
				},
				{
					"description": [
						"URL-encoded form data sends key-value pairs in the request body.",
						"Special characters become percent-encoded codes.",
						"Browsers use it when submitting HTML forms."
					],
					"name": "application/x-www-form-urlencoded"
				},
				{
					"description": [
						"MP4 container holds video, audio, subtitles, and images.",
						"It is compatible with most players and devices.",
						"Online platforms use MP4 for smooth video streaming."
					],
					"name": "video/mp4"
				}
			]
		},
		{
			"description": [
				"Field name included in form-encoded POST or PUT requests.",
				"It pairs a field name with its value in the request body.",
				"Correct field entries ensure servers receive each form item."
			],
			"name": "Field",
			"type": "KeyValue"
		},
		{
			"description": [
				"Key-value pairs that carry extra information in the request.",
				"Each header uses a name and value separated by an equals sign.",
				"Multiple headers let you pass options like authentication or format."
			],
			"name": "Header",
			"type": "KeyValue"
		},
		{
			"description": [
				"A list of available HTTP actions like GET, POST, or custom methods.",
				"Values come from HttpMethod plugins and update automatically when new methods are added.",
				"Correct method choice ensures the server handles the request as intended."
			],
			"name": "Method",
			"type": "HttpMethod"
		},
		{
			"description": [
				"The address where the HTTP request is sent.",
				"It tells the plugin which server and resource to contact.",
				"Accurate URLs ensure requests reach the intended endpoint."
			],
			"name": "Url",
			"type": "String"
		}
	],
	"platforms": [
		"Any"
	],
	"pluginType": "Action",
	"properties": [
		{
			"description": [
				"A single string or expression that covers address, method, headers, body, and other settings for a web request.",
				"It can be a fixed string or an expression that runs at execution time."
			],
			"mandatory": true,
			"name": "Argument",
			"type": "String|Expression"
		},
		{
			"description": [
				"An attribute name used to get information from an XML element.",
				"It only applies to XML data and works alongside element location.",
				"Accurate naming ensures you capture the right value."
			],
			"mandatory": false,
			"name": "OnAttribute",
			"type": "String"
		},
		{
			"description": [
				"A path expression that finds the right part of XML or JSON data.",
				"XPath works for XML and JSONPath works for JSON responses.",
				"Correct path choice ensures you target the intended data."
			],
			"mandatory": false,
			"name": "OnElement",
			"type": "String"
		},
		{
			"default": "(?s).*",
			"description": [
				"A text pattern that refines data after extraction.",
				"It keeps only the parts that match the pattern.",
				"Refined data makes following steps more accurate.",
				"Pattern matching helps parse or check specific text."
			],
			"mandatory": false,
			"name": "RegularExpression",
			"type": "Regex"
		}
	],
	"protocol": {
		"apiDocumentation": "None",
		"w3c": "None"
	},
	"summary": [
		"The SendHttpRequest plugin lets automation workflows send HTTP GET, POST, PUT, DELETE, or custom method requests to any URL at runtime.",
		"It allows configuring headers, body content, and query parameters on the fly for precise API interactions.",
		"It captures response status codes, headers, and body content to feed into subsequent automation steps."
	]
}