{
	"aliases": [
		"date",
		"NewDate"
	],
	"author": {
		"link": "https://www.linkedin.com/in/roei-sabag-247aa18/",
		"name": "Roei Sabag"
	},
	"categories": [
		"Utilities"
	],
	"context": {
		"integration": {
			"github": {
				"document": "https://github.com/g4-api/g4-plugins/blob/main/docs/Macros/New-Date.md",
				"source": "https://github.com/g4-api/g4-plugins/blob/main/src/G4.Plugins.Common/Macros/NewDate.cs"
			}
		}
	},
	"description": [
		"### Purpose",
		"",
		"The primary purpose of the NewDate macro plugin is to provide functionalities for date and time manipulation, including adding or subtracting time, extracting specific date parts, and formatting dates according to custom formats.",
		"",
		"### Key Features",
		"",
		"| Feature              | Description                                                                 |",
		"|----------------------|-----------------------------------------------------------------------------|",
		"| Date Manipulation    | Add or subtract time from the current date and time.                        |",
		"| Date Formatting      | Format dates according to custom formats.                                   |",
		"| Date Part Extraction | Extract specific parts of the date and time, such as year, month, day, etc. |",
		"",
		"### Usages in RPA",
		"",
		"| Usage            | Description                                                             |",
		"|------------------|-------------------------------------------------------------------------|",
		"| Date Calculation | Perform calculations involving dates and times in automation workflows. |",
		"| Date Formatting  | Format dates for logging or display purposes.                           |",
		"| Data Processing  | Extract specific date parts for further processing or validation.       |",
		"",
		"### Usages in Automation Testing",
		"",
		"| Usage             | Description                                                                                |",
		"|-------------------|--------------------------------------------------------------------------------------------|",
		"| Date Verification | Verify date-related behaviors or outputs during automated testing.                         |",
		"| Data Generation   | Generate test data involving dates and times.                                              |",
		"| Test Scheduling   | Schedule tests to run at specific dates or times for regression testing or other purposes. |"
	],
	"examples": [
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Element not found",
						"Empty macro output",
						"Incorrect date format",
						"Invalid CSS selector",
						"Locator not matching",
						"SendKeys failure"
					],
					"expected_result": "The plugin sends the current date and time as keystrokes to the element matching the CSS selector `.example-element`.",
					"notes": "This example uses the `NewDate` macro (`{{$New-Date}}`) to generate the argument for the `SendKeys` plugin.",
					"use_case": "sendkeys_with_newdate_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro",
				"",
				"Use the `SendKeys` plugin to send the current date and time to the specified element matching the CSS selector `.example-element`.",
				"Generate the argument by applying the `NewDate` macro (`{{$New-Date}}`), which returns the current local date and time as a string."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date}}",
				"locator": "CssSelector",
				"onElement": ".example-element",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid date format",
						"Missing parameter name",
						"Nested macro syntax error",
						"Parameter name conflict",
						"Plugin failure",
						"Session scope unsupported",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The RegisterParameter plugin registers a session-scoped parameter named DataParameter with the current date in yyyy-MM-dd format.",
					"notes": "This example first evaluates the `NewDate` macro (`{{$New-Date --Format:yyyy-MM-dd}}`) to produce the date string, then passes that string verbatim in the argument (`--Name:DataParameter --Value:<date string> --Scope:Session`) to the `RegisterParameter` plugin.",
					"use_case": "register_parameter_current_date_session",
					"version": "1.0.0"
				},
				"labels": [
					"DateTime",
					"Macro",
					"NewDate",
					"Parameter",
					"RegisterParameter",
					"Session"
				]
			},
			"description": [
				"### RegisterParameter Plugin with NewDate Macro",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --Format:yyyy-MM-dd}}`) to produce a date string in `yyyy-MM-dd` format.",
				"Pass the verbatim argument string (`{{$ --Name:DataParameter --Value:<date string> --Scope:Session}}`) to the `RegisterParameter` plugin to register a session-scoped parameter named `DataParameter` with the generated date string."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$ --Name:DataParameter --Value:{{$New-Date --Format:yyyy-MM-dd}} --Scope:Session}}",
				"pluginName": "RegisterParameter"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid date format",
						"Log file inaccessible",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"Plugin not installed",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The WriteLog plugin writes a log entry with the message 'Log entry created at YYYY-MM-DD' to the logging system.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --Format:yyyy-MM-dd}}`) to produce a date string, then passes the inline message `Log entry created at {{$New-Date --Format:yyyy-MM-dd}}` (containing the macro call itself) directly to the WriteLog plugin.",
					"use_case": "writelog_with_newdate_macro",
					"version": "1.0.0"
				},
				"labels": [
					"DateTime",
					"Log",
					"Macro",
					"NewDate",
					"WriteLog"
				]
			},
			"description": [
				"### WriteLog Plugin with NewDate Macro",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --Format:yyyy-MM-dd}}`) to generate the current date string in `yyyy-MM-dd` format.",
				"Pass the message `Log entry created at {{$New-Date --Format:yyyy-MM-dd}}` to the `WriteLog` plugin to write a log entry that includes the generated date."
			],
			"rule": {
				"$type": "Action",
				"argument": "Log entry created at {{$New-Date --Format:yyyy-MM-dd}}",
				"pluginName": "WriteLog"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Invalid date format",
						"Locator not matching",
						"Macro execution failure",
						"Missing argument",
						"SendKeys failure",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The plugin sends the current UTC date in yyyy-MM-dd format as keystrokes to the element matching the CSS selector `.example-element`.",
					"notes": "This example first evaluates the `NewDate` macro (`{{$New-Date --Format:yyyy-MM-dd --Utc}}`) to produce a UTC date string, then passes that string as the argument to the `SendKeys` plugin.",
					"use_case": "sendkeys_with_newdate_macro_utc",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"Utc"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro in UTC",
				"",
				"Use the `SendKeys` plugin to send the current UTC date to the element matching the CSS selector `.example-element`.",
				"Generate the argument by applying the `NewDate` macro with format and UTC flag (`{{$New-Date --Format:yyyy-MM-dd --Utc}}`)."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --Format:yyyy-MM-dd --Utc}}",
				"locator": "CssSelector",
				"onElement": ".example-element",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid XPath expression",
						"Invalid year format",
						"Locator not matching",
						"Macro execution failure",
						"Multiple matching elements",
						"Nested macro syntax error",
						"No matching element",
						"Plugin failure",
						"Unexpected whitespace in locator"
					],
					"expected_result": "The Click plugin evaluates the inline NewDate macro at runtime and clicks the button whose text matches the current year.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --Format:yyyy}}`) to produce the current year string, then passes the inline locator `//button[contains(text(), '{{$New-Date --Format:yyyy}}')]` (containing the macro call itself) directly to the Click plugin.",
					"use_case": "click_button_current_year_xpath",
					"version": "1.0.0"
				},
				"labels": [
					"Click",
					"Macro",
					"NewDate",
					"Xpath"
				]
			},
			"description": [
				"### Click Plugin with NewDate Macro for Year",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --Format:yyyy}}`) to generate the current year string.",
				"Use the `Click` plugin with the XPath locator string `//button[contains(text(), '{{$New-Date --Format:yyyy}}')]` so that the plugin evaluates the inline macro call at runtime and clicks the matching button."
			],
			"rule": {
				"$type": "Action",
				"locator": "Xpath",
				"onElement": "//button[contains(text(), '{{$New-Date --Format:yyyy}}')]",
				"pluginName": "Click"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid epoch value",
						"Log file inaccessible",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"Plugin not installed",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The WriteLog plugin writes a log entry containing the current date and time in Unix epoch format to the logging system.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --UnixEpoch}}`) to produce a Unix epoch timestamp, then passes the inline argument `{{$New-Date --UnixEpoch}}` (containing the macro call) directly to the WriteLog plugin.",
					"use_case": "writelog_with_unixepoch_newdate_macro",
					"version": "1.0.0"
				},
				"labels": [
					"Log",
					"Macro",
					"NewDate",
					"UnixEpoch",
					"WriteLog"
				]
			},
			"description": [
				"### WriteLog Plugin with NewDate Macro for Unix Epoch",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --UnixEpoch}}`) to generate the current Unix epoch timestamp.",
				"Pass the argument `{{$New-Date --UnixEpoch}}` to the `WriteLog` plugin so that the plugin evaluates the macro call at runtime and writes a log entry containing the generated timestamp."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --UnixEpoch}}",
				"pluginName": "WriteLog"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Date outside valid OLE range",
						"Empty macro output",
						"Floating point precision error",
						"Invalid CSS selector",
						"Invalid OLE Automation date value",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current date and time as an OLE Automation date value into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --OaDate}}`) to produce an OLE Automation date floating-point value, then passes the inline argument `{{$New-Date --OaDate}}` (containing the macro call) directly to the SendKeys plugin.",
					"use_case": "sendkeys_ole_automation_date_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"OaDate",
					"SendKeys",
					"TextField"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for OLE Automation Date",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --OaDate}}`) to generate the current date and time as an OLE Automation date value.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --OaDate}}` so that the plugin inputs the generated OLE Automation date value into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --OaDate}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current year into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --DatePart:Year}}`) to produce the current year string, then passes the inline argument `{{$New-Date --DatePart:Year}}` (containing the macro call) directly to the SendKeys plugin to input into the element matching the CSS selector `.text-field`.",
					"use_case": "sendkeys_with_newdate_year_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"TextField"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for Year",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --DatePart:Year}}`) to generate the current year string.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --DatePart:Year}}` so that the plugin inputs the generated year into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --DatePart:Year}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Invalid DatePart parameter",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current month into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --DatePart:Month}}`) to produce the current month string, then passes the inline argument `{{$New-Date --DatePart:Month}}` (containing the macro call) directly to the SendKeys plugin.",
					"use_case": "sendkeys_with_newdate_month_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"TextField"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for Month",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --DatePart:Month}}`) to generate the current month string.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --DatePart:Month}}` so that the plugin evaluates the inline macro call at runtime and inputs the generated month into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --DatePart:Month}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Invalid DatePart parameter",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current day into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --DatePart:Day}}`) to produce the current day string, then passes the inline argument `{{$New-Date --DatePart:Day}}` (containing the macro call) directly to the SendKeys plugin.",
					"use_case": "sendkeys_with_newdate_day_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"TextField"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for Day",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --DatePart:Day}}`) to generate the current day string.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --DatePart:Day}}` so that the plugin evaluates the inline macro call at runtime and inputs the generated day into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --DatePart:Day}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Invalid DatePart parameter",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current hour into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --DatePart:Hour}}`) to produce the current hour string, then passes the inline argument `{{$New-Date --DatePart:Hour}}` (containing the macro call) directly to the SendKeys plugin.",
					"use_case": "sendkeys_with_newdate_hour_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"TextField"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for Hour",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --DatePart:Hour}}`) to generate the current hour string.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --DatePart:Hour}}` so that the plugin evaluates the inline macro call at runtime and inputs the generated hour into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --DatePart:Hour}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Invalid DatePart parameter",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current minute into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --DatePart:Minute}}`) to produce the current minute string, then passes the inline argument `{{$New-Date --DatePart:Minute}}` (containing the macro call) directly to the SendKeys plugin.",
					"use_case": "sendkeys_with_newdate_minute_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"TextField"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for Minute",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --DatePart:Minute}}`) to generate the current minute string.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --DatePart:Minute}}` so that the plugin evaluates the inline macro call at runtime and inputs the generated minute into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --DatePart:Minute}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Invalid DatePart parameter",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current second into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --DatePart:Second}}`) to produce the current second string, then passes the inline argument `{{$New-Date --DatePart:Second}}` (containing the macro call) directly to the SendKeys plugin.",
					"use_case": "sendkeys_with_newdate_second_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"TextField"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for Second",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --DatePart:Second}}`) to generate the current second string.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --DatePart:Second}}` so that the plugin evaluates the inline macro call at runtime and inputs the generated second into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --DatePart:Second}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Invalid DatePart parameter",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current millisecond string into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --DatePart:Millisecond}}`) to produce the current millisecond string, then passes the inline argument `{{$New-Date --DatePart:Millisecond}}` (containing the macro call) directly to the SendKeys plugin.",
					"use_case": "sendkeys_with_newdate_millisecond_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"TextField"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for Millisecond",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --DatePart:Millisecond}}`) to generate the current millisecond string.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --DatePart:Millisecond}}` so that the plugin evaluates the inline macro call at runtime and inputs the generated millisecond into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --DatePart:Millisecond}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Invalid DatePart parameter",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current nanosecond string into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --DatePart:Nanosecond}}`) to produce the current nanosecond string, then passes the inline argument `{{$New-Date --DatePart:Nanosecond}}` (containing the macro call) directly to the SendKeys plugin.",
					"use_case": "sendkeys_with_newdate_nanosecond_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"TextField"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for Nanosecond",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --DatePart:Nanosecond}}`) to generate the current nanosecond string.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --DatePart:Nanosecond}}` so that the plugin evaluates the inline macro call at runtime and inputs the generated nanosecond into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --DatePart:Nanosecond}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Invalid DatePart parameter",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current microsecond string into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --DatePart:Microsecond}}`) to produce the current microsecond string, then passes the inline argument `{{$New-Date --DatePart:Microsecond}}` (containing the macro call) directly to the SendKeys plugin to input into the element matching the CSS selector `.text-field`.",
					"use_case": "sendkeys_with_newdate_microsecond_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"TextField"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for Microsecond",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --DatePart:Microsecond}}`) to generate the current microsecond string.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --DatePart:Microsecond}}` so that the plugin evaluates the inline macro call at runtime and inputs the generated microsecond into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --DatePart:Microsecond}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"Empty macro output",
						"Invalid CSS selector",
						"Invalid tick value",
						"Locator not matching",
						"Macro execution failure",
						"Nested macro syntax error",
						"No argument provided",
						"Plugin failure",
						"SendKeys plugin not installed",
						"Text field non-editable",
						"Tick conversion error",
						"Tick value out of range",
						"Unexpected whitespace in argument"
					],
					"expected_result": "The SendKeys plugin inputs the current tick count into the text field matching the CSS selector `.text-field`.",
					"notes": "This example first evaluates the NewDate macro (`{{$New-Date --DatePart:Ticks}}`) to produce the current tick count string, then passes the inline argument `{{$New-Date --DatePart:Ticks}}` (containing the macro call) directly to the SendKeys plugin.",
					"use_case": "sendkeys_with_newdate_ticks_macro",
					"version": "1.0.0"
				},
				"labels": [
					"CssSelector",
					"DateTime",
					"Macro",
					"NewDate",
					"SendKeys",
					"TextField",
					"Ticks"
				]
			},
			"description": [
				"### SendKeys Plugin with NewDate Macro for Ticks",
				"",
				"Evaluate the `NewDate` macro (`{{$New-Date --DatePart:Ticks}}`) to generate the current tick count string.",
				"Use the `SendKeys` plugin with the CSS selector `.text-field` and the argument `{{$New-Date --DatePart:Ticks}}` so that the plugin evaluates the inline macro call at runtime and inputs the generated tick count into the text field."
			],
			"rule": {
				"$type": "Action",
				"argument": "{{$New-Date --DatePart:Ticks}}",
				"locator": "CssSelector",
				"onElement": ".text-field",
				"pluginName": "SendKeys"
			}
		}
	],
	"key": "New-Date",
	"manifestVersion": 4,
	"parameters": [
		{
			"description": [
				"Amount of time to add to the current date and time.",
				"Use positive or negative values to move the timestamp forward or backward.",
				"Supports durations such as days, hours, minutes, and seconds."
			],
			"mandatory": false,
			"name": "AddTime",
			"type": "Time"
		},
		{
			"description": [
				"Amount of time to subtract from the current date and time.",
				"Define the duration in units like days, hours, minutes, or seconds.",
				"Creates a past timestamp relative to now."
			],
			"mandatory": false,
			"name": "SubtructTime",
			"type": "Time"
		},
		{
			"default": "yyyy-MM-ddTHH:mm:ss.ffffffK",
			"description": [
				"Custom pattern that dictates how the date and time are displayed.",
				"Uses standard .NET format tokens for precise control over order, separators, and precision.",
				"Defaults to `yyyy-MM-ddTHH:mm:ss.ffffffK` when no format is provided."
			],
			"links": [
				{
					"link": "https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings",
					"title": "Custom Date and Time Format Strings"
				},
				{
					"link": "https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings",
					"title": "Standard Date and Time Format Strings"
				}
			],
			"mandatory": false,
			"name": "Format",
			"type": "String"
		},
		{
			"description": [
				"Choose one element of the date and time, like year, month, or day, when you need only part of the full timestamp.",
				"Selecting 'Hour' or 'Minute' lets you work with the exact time of day for scheduling or logging.",
				"Using 'Second', 'Millisecond', or smaller units helps when you need precise timing in your application.",
				"Specifying 'Ticks' returns the raw tick count for very fine measurements and analysis."
			],
			"mandatory": false,
			"name": "DatePart",
			"type": "String",
			"values": [
				{
					"description": [
						"Extracts the year from the date and time input.",
						"Using the year value helps group or filter data by calendar year.",
						"Value appears as a four-digit number like 2025."
					],
					"name": "Year"
				},
				{
					"description": [
						"Extracts the month number from the date and time, where January is 1 and December is 12.",
						"Month values help sort events or data within a single year.",
						"Useful for generating monthly reports or determining seasonal patterns."
					],
					"name": "Month"
				},
				{
					"description": [
						"Extracts the day of the month from the date and time.",
						"Day values range from 1 to 31 depending on the month.",
						"Scheduling or tracking tasks on specific dates becomes easier."
					],
					"name": "Day"
				},
				{
					"description": [
						"Extracts the hour part of the time using a 24-hour clock.",
						"Hour values range from 0 to 23.",
						"This is useful when you need to trigger actions at a specific hour."
					],
					"name": "Hour"
				},
				{
					"description": [
						"Extracts the minute part of the time, ranging from 0 to 59.",
						"Using minutes allows finer-grained time schedules or logs.",
						"Combining with hours defines precise times like 14:30."
					],
					"name": "Minute"
				},
				{
					"description": [
						"Extracts the second part of the time, ranging from 0 to 59.",
						"Seconds allow tracking events at a one-second resolution.",
						"Useful for timestamping or measuring short delays."
					],
					"name": "Second"
				},
				{
					"description": [
						"Extracts the millisecond part of the time, ranging from 0 to 999.",
						"Milliseconds help measure short intervals with high precision.",
						"Essential for applications that record or analyze rapid events."
					],
					"name": "Millisecond"
				},
				{
					"description": [
						"Extracts the nanosecond component, measuring one billionth of a second.",
						"Nanoseconds provide extremely fine timing for specialized scenarios.",
						"Useful for high-resolution timestamps in scientific or performance analysis."
					],
					"name": "Nanosecond"
				},
				{
					"description": [
						"Extracts the microsecond component, measuring one millionth of a second.",
						"Microseconds allow very precise time calculations below the millisecond level.",
						"Helpful for profiling code performance or detailed logging."
					],
					"name": "Microsecond"
				},
				{
					"description": [
						"Extracts the total number of ticks from the time value, where each tick is 100 nanoseconds.",
						"Ticks provide the raw count of time intervals for maximum precision.",
						"Useful for comparing or calculating time spans at the lowest resolution."
					],
					"name": "Ticks"
				}
			]
		},
		{
			"description": [
				"Records date and time values using Coordinated Universal Time instead of the local time zone.",
				"Standardizing on UTC helps avoid errors caused by time zone differences.",
				"A universal time reference improves consistency when processing timestamps across regions."
			],
			"mandatory": false,
			"name": "Utc",
			"type": "Switch"
		},
		{
			"description": [
				"Converts date and time values into the number of seconds that have elapsed since January 1, 1970 (the Unix epoch).",
				"Epoch time is a common format for storing and comparing timestamps across systems.",
				"Using a numeric timestamp simplifies interoperability across platforms and languages."
			],
			"mandatory": false,
			"name": "UnixEpoch",
			"type": "Switch"
		},
		{
			"description": [
				"Transforms date and time values into OLE Automation Date format, which represents dates as floating-point numbers.",
				"The integer part counts days since December 30, 1899 and the fractional part represents the time of day.",
				"Many Microsoft automation tools use this format to maintain compatibility."
			],
			"mandatory": false,
			"name": "OaDate",
			"type": "Switch"
		},
		{
			"description": [
				"Returns the day number within the year for the given date and time.",
				"Day-of-year values help compute spans and filter data across an annual period.",
				"Continuous day counts support features like annual reports and milestone tracking."
			],
			"mandatory": false,
			"name": "DayOfYear",
			"type": "Switch"
		},
		{
			"description": [
				"Retrieves the day of the week for the provided date and time.",
				"Weekday information helps schedule tasks and enforce business rules.",
				"Calendar views and weekly summaries depend on accurate weekday values."
			],
			"mandatory": false,
			"name": "DayOfWeek",
			"type": "Switch"
		}
	],
	"platforms": [
		"Any"
	],
	"pluginType": "Macro",
	"protocol": {
		"apiDocumentation": "None",
		"w3c": "None"
	},
	"summary": [
		"The NewDate plugin instantly creates date and time values, including the current moment or a value shifted by an amount you choose.",
		"It can return full timestamps, individual parts such as year or minute, or special formats like Unix epoch and OLE Automation numbers.",
		"Custom formatting and a UTC switch help automations stamp logs, fill inputs, and schedule tasks without hand-written date math."
	]
}
