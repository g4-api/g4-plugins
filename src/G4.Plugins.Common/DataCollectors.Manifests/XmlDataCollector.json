{
	"author": {
		"name": "Roei Sabag",
		"link": "https://www.linkedin.com/in/roei-sabag-247aa18/"
	},
	"categories": [
		"DataManagement"
	],
	"context": {
		"integration": {
			"github": {
				"document": "https://github.com/g4-api/g4-plugins/blob/main/docs/DataCollectors/XmlDataCollector.md",
				"source": "https://github.com/g4-api/g4-plugins/blob/main/src/G4.Plugins.Common/DataCollectors/XmlDataCollector.cs"
			},
			"rag": {
				"description": "XmlDataCollector serializes extraction outputs into an XML file, supporting real-time streaming and bulk writes. It hooks into extraction rules, manages file creation or appending, and ensures reliable integration with XML-based services while preserving workflow stability and flexibility.",
				"qa": [
					{
						"question": "What is the XmlDataCollector plugin and why does it matter?",
						"answer": "XmlDataCollector converts extracted data items into XML elements and writes them to a file, enabling seamless integration with XML-based systems, reporting tools, and downstream workflows."
					},
					{
						"question": "How do its main capabilities work and what are its primary parameters?",
						"answer": "It embeds into extraction rules via a dataCollector object. The main parameters are ForEntity (true for streaming each record, false for bulk write), Source (the XML file path), and Type (must be XmlDataCollector)."
					},
					{
						"question": "How does XmlDataCollector embed into external tools or workflow designers?",
						"answer": "In workflow definitions it appears as a DataCollector step. You specify it under an extraction rule with dataCollector settings, allowing low-code design tools to configure file path and streaming mode without custom coding."
					},
					{
						"question": "What are recommended configuration patterns and troubleshooting tips?",
						"answer": "Use ForEntity=true for large or continuous streams to avoid high memory use. For smaller batches, set ForEntity=false to reduce I/O calls. Verify XPath and regex rules to prevent missing or malformed records, and ensure file paths are writable."
					},
					{
						"question": "How are action or rule definitions structured for this plugin?",
						"answer": "You define an Extraction rule ($type “Extraction”) with a dataCollector object containing ForEntity, Source, and Type fields. Nested rule entries ($type “Content”) include key, onElement, and regularExpression to shape each XML element."
					},
					{
						"question": "How does the plugin record failures and control workflow behavior on error?",
						"answer": "On errors it adds an exception to the response and log stream. By default the workflow continues unless you configure it to stop on error in your automation designer."
					},
					{
						"question": "What is the manifestVersion?",
						"answer": "The manifestVersion is 4, indicating the schema iteration the plugin adheres to for property and parameter definitions."
					},
					{
						"question": "Who is the author?",
						"answer": "The author is Roei Sabag (https://www.linkedin.com/in/roei-sabag-247aa18/)."
					},
					{
						"question": "What are the categories?",
						"answer": "This plugin is categorized under DataManagement, reflecting its role in collecting and organizing data."
					},
					{
						"question": "What platforms does it support?",
						"answer": "The plugin supports Any platform, making it compatible with Windows, Linux, and other environments."
					},
					{
						"question": "What is the pluginType?",
						"answer": "The pluginType is DataCollector, indicating it focuses on gathering and writing data outputs."
					},
					{
						"question": "What scopes does it use?",
						"answer": "The defined scope is Any, meaning it can operate in any context or isolation level within the automation engine."
					},
					{
						"question": "What is the key for this plugin?",
						"answer": "The key is XmlDataCollector, which is used to reference this plugin in workflow definitions."
					},
					{
						"question": "What is the summary?",
						"answer": "XmlDataCollector serializes extraction outputs into an XML file, wrapping records under a default root element. Supports streaming writes for large data sets or bulk writes for smaller runs. Ideal for integration with XML-based systems and reporting tools."
					},
					{
						"question": "What properties are defined?",
						"answer": "Properties include ForEntity (Boolean, optional, toggles streaming vs buffered write), Source (String, mandatory, file path), and Type (DataCollector, mandatory, must be XmlDataCollector)."
					},
					{
						"question": "What parameters are defined?",
						"answer": "This plugin does not define a separate parameters array and relies on its properties section for configuration."
					},
					{
						"question": "What protocol information is included?",
						"answer": "Protocol settings are apiDocumentation: None and w3c: None, indicating no external API or W3C schema references."
					},
					{
						"question": "Where can I find the GitHub documentation?",
						"answer": "Documentation is available at https://github.com/g4-api/g4-plugins/blob/main/docs/DataCollectors/XmlDataCollector.md"
					},
					{
						"question": "Where can I find the source code?",
						"answer": "Source code is available at https://github.com/g4-api/g4-plugins/blob/main/src/G4.Plugins.Common/DataCollectors/XmlDataCollector.cs"
					}
				]
			}
		}
	},
	"description": [
		"### Purpose",
		"",
		"XmlDataCollector takes your extraction-rule outputs and saves them into an XML file. It opens or creates the specified file, wraps records in a default root element, and either appends each record element as it’s extracted or writes the full document at the end of the run. This format simplifies integration with XML-based services and tools.",
		"",
		"### Key Features and Functionality",
		"",
		"| Feature                | Description                                                                             |",
		"|------------------------|-----------------------------------------------------------------------------------------|",
		"| Extraction Integration | Hooks into your extraction rules so every item becomes an XML element.                  |",
		"| Write Modes            | Supports streaming (`ForEntity=true`) or bulk writes (`ForEntity=false`) at end of run. |",
		"",
		"### Usages in RPA",
		"",
		"| Use Case           | Description                                                                |",
		"|--------------------|----------------------------------------------------------------------------|",
		"| Web Scraping       | Serializes scraped items into XML for legacy system ingestion or analysis. |",
		"| Real-Time Capture  | Streams each record as an XML element for live dashboards.                 |",
		"| Data Aggregation   | Collects outputs from multiple sources into a single XML document.         |",
		"| System Interchange | Produces XML files consumable by other services or microservices.          |",
		"",
		"### Usages in Automation Testing",
		"",
		"| Use Case           | Description                                                           |",
		"|--------------------|-----------------------------------------------------------------------|",
		"| Test Result Export | Records pass/fail status as XML elements for CI systems or reporting. |",
		"| Metrics Collection | Captures timing and resource usage in XML for downstream analysis.    |"
	],
	"examples": [
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"CSS selector syntax error",
						"Element missing",
						"Malformed DOM",
						"Multiple elements found",
						"Regex failure",
						"TagName typo",
						"Unexpected whitespace",
						"XPath mismatch",
						"XPath syntax error"
					],
					"expected_result": "Each hotel-location string is extracted and appended as an XML element under the <Records> root in real time.",
					"notes": "Writes '<Records>' once, then for each match writes '<Record><Location>…</Location></Record>' (text trimmed, converted to string, regex-extracted up to 100 chars), and closes with '</Records>'.",
					"use_case": "element_text_extraction_streaming_xml",
					"version": "1.0"
				},
				"labels": [
					"ElementTextExtraction",
					"Streaming",
					"XmlExtraction",
					"XmlFileWrite"
				]
			},
			"description": [
				"### Stream Hotel Locations to XML",
				"",
				"Text is trimmed to remove whitespace, converted to a string, then regex-extracted (up to 100 characters).",
				"This example demonstrates how to extract hotel locations from each `<div class='hotel'>` element and stream each as an XML element into `DataFile.xml` in real time.",
				"It uses `extractionScope: \"Elements\"` with XPath `//div[@class='hotel']`, applies a nested rule to the `<p>` elements starting with `Location:`, and sets `forEntity` to `true` for streaming writes.",
				"A regular expression `(?<=\\\\w+:).*` is applied to the text content to extract the substring following the label into a capture group."
			],
			"rule": {
				"$type": "Extraction",
				"dataCollector": {
					"forEntity": true,
					"source": "DataFile.xml",
					"type": "XmlDataCollector"
				},
				"extractionScope": "Elements",
				"onElement": "//div[@class='hotel']",
				"rules": [
					{
						"$type": "Content",
						"key": "Location",
						"onElement": ".//p[starts-with(.,'Location:')]",
						"regularExpression": "(?<=\\\\w+:).*"
					}
				]
			}
		},
		{
			"context": {
				"annotations": {
					"edge_cases": [
						"CSS selector syntax error",
						"Element missing",
						"Malformed DOM",
						"Multiple elements found",
						"Regex failure",
						"TagName typo",
						"Unexpected whitespace",
						"XPath mismatch",
						"XPath syntax error"
					],
					"expected_result": "Each hotel-location string is extracted, collected, and written as XML elements under a <Records> root in a single document upon completion.",
					"notes": "Writes '<Records>' once, then for each match buffers '<Record><Location>…</Location></Record>' (text trimmed, converted to string, regex-extracted up to 100 chars) in memory, and closes with '</Records>'.",
					"use_case": "element_text_extraction_bulk_xml",
					"version": "1.0"
				},
				"labels": [
					"BulkWrite",
					"ElementTextExtraction",
					"XmlExtraction",
					"XmlFileWrite"
				]
			},
			"description": [
				"### Bulk Hotel Locations to XML",
				"",
				"Text is trimmed to remove whitespace, converted to a string, then regex-extracted (up to 100 characters).",
				"This example demonstrates how to extract hotel locations from each `<div class='hotel'>` element and write them all as XML elements under a `<Records>` root in `DataFile.xml` upon completion.",
				"It uses `extractionScope: \"Elements\"` with XPath `//div[@class='hotel']`, applies a nested rule to the `<p>` elements starting with `Location:`, and sets `forEntity` to `false` for bulk buffering.",
				"A regular expression `(?<=\\\\w+:).*` is applied to the text content to extract the substring following the label into a capture group."
			],
			"rule": {
				"$type": "Extraction",
				"dataCollector": {
					"forEntity": false,
					"source": "DataFile.xml",
					"type": "XmlDataCollector"
				},
				"extractionScope": "Elements",
				"onElement": "//div[@class='hotel']",
				"rules": [
					{
						"$type": "Content",
						"key": "Location",
						"onElement": ".//p[starts-with(.,'Location:')]",
						"regularExpression": "(?<=\\\\w+:).*"
					}
				]
			}
		}
	],
	"key": "XmlDataCollector",
	"manifestVersion": 4,
	"platforms": [
		"Any"
	],
	"pluginType": "DataCollector",
	"properties": [
		{
			"description": [
				"Set to “true” to write each record as soon as it is ready so you can see results right away and start using them without waiting.",
				"Set to “false” to wait until all records are ready before writing so you can view everything at once and keep your file complete."
			],
			"mandatory": false,
			"name": "ForEntity",
			"type": "Boolean"
		},
		{
			"description": [
				"Enter the path where your XML file will be saved so you know where to find it later and keep your files organized.",
				"If the file does not exist, a new one is created at that location so you do not have to set it up yourself."
			],
			"mandatory": true,
			"name": "Source",
			"type": "String"
		},
		{
			"description": [
				"Use the value “XmlDataCollector” so the system writes your file in the correct format and avoids errors.",
				"Choosing a different value will use another process and may store your data in the wrong place.",
				"The list of values updates on its own when new options are added so you always have the latest choices."
			],
			"mandatory": true,
			"name": "Type",
			"type": "DataCollector"
		}
	],
	"protocol": {
		"apiDocumentation": "None",
		"w3c": "None"
	},
	"summary": [
		"The XmlDataCollector plugin serializes extraction outputs into an XML file, wrapping records under a default root element.",
		"Supports streaming writes for large data sets or bulk writes for smaller runs.",
		"Ideal for integration with XML-based systems and reporting tools."
	]
}
